[
  {
    "name": "TP1",
    "exercises": [
      {
        "sequence_id": 0,
        "title": "Hello World",
        "lang": "python",
        "instructions": "Réalisez un programme qui affiche \"Hello World\".\n",
        "tests": "from unittest.mock import patch\nfrom unittest import TestCase\nfrom inspect import getmembers\n\nimport sys\nfrom contextlib import contextmanager\nfrom io import StringIO\n\n@contextmanager\ndef captured_output():\n    new_out = StringIO()\n    old_out = sys.stdout\n    try:\n        sys.stdout = new_out\n        yield sys.stdout\n    finally:\n        sys.stdout = old_out\n\nwith captured_output() as out:\n    import moduletotest\n\nclass Test(TestCase):\n    def test_hello_world(self):\n        output = out.getvalue().strip()\n        assert output == 'Hello World', \"La valeur d'affichage n'est pas 'Hello World'\"\n",
        "solution": "print(\"Hello World\")\n",
        "template_regions": [
          ""
        ],
        "template_regions_rw": [
          0
        ],
        "difficulty": 0,
        "score": 0,
        "creation_date": "2020-02-28T12:32:53.134Z"
      },
      {
        "sequence_id": 1,
        "title": "Affectation",
        "lang": "python",
        "instructions": "Réalisez un programme qui affecte une valeur à une variable 'myvar' puis qui affiche son contenu\n",
        "tests": "from unittest.mock import patch\nfrom unittest import TestCase\nfrom inspect import getmembers, getsource\n\nimport sys\nfrom contextlib import contextmanager\nfrom io import StringIO\n\n@contextmanager\ndef captured_output():\n    new_out = StringIO()\n    old_out = sys.stdout\n    try:\n        sys.stdout = new_out\n        yield sys.stdout\n    finally:\n        sys.stdout = old_out\n\nwith captured_output() as out:\n    import moduletotest\n\nclass Test(TestCase):\n    def test_affectation_variable(self):\n        members = getmembers(moduletotest)\n\n        valueofa = [item for item in members if item[0] == 'myvar']\n        assert len(valueofa) == 1, \"La variable myvar n'existe pas\"\n\n    def test_affichage(self):\n        output = out.getvalue().strip()\n        assert output != '', \"Le programme n'affiche rien\"\n\n    def test_egalite(self):\n        output = out.getvalue().strip()\n        members = getmembers(moduletotest)\n\n        valueofmyvar = [item for item in members if item[0] == 'myvar']\n        assert len(valueofmyvar) == 1\n        assert output == str(valueofmyvar[0][1]), \"La valeur d'affichage est différente du contenu de myvar\"\n        source = getsource(moduletotest)\n        assert \"print(myvar)\" in source, \"Vous n'affichez pas strictement le contenu de myvar\"\n\n\n\n",
        "solution": "myvar = \"contenu quelconque\"\nprint(myvar)\n",
        "template_regions": [
          ""
        ],
        "template_regions_rw": [
          0
        ],
        "difficulty": 0,
        "score": 0,
        "creation_date": "2020-02-28T12:32:53.135Z"
      },
      {
        "sequence_id": 2,
        "title": "Saisie",
        "lang": "python",
        "instructions": "Écrivez un programme qui demande son nom à l'utilisateur, par exemple \"John\", puis lui affiche le message \"Bonjour John, comment allez-vous ?\"\n",
        "tests": "from unittest.mock import patch\nfrom unittest import TestCase\nfrom inspect import getmembers\n\nimport sys\nimport imp\nfrom contextlib import contextmanager\nfrom io import StringIO\n\n@contextmanager\ndef captured_output():\n    new_out = StringIO()\n    old_out = sys.stdout\n    try:\n        sys.stdout = new_out\n        yield sys.stdout\n    finally:\n        sys.stdout = old_out\n\ndef load_module():\n    if 'moduletotest' in sys.modules:\n        imp.reload(sys.modules['moduletotest'])\n    else:\n        import moduletotest\n\ndef get_cleaned_output(out, lines):\n    output = out.getvalue().strip()\n    l = output.split('\\n')\n    return l[-lines:]\n\nclass Test(TestCase):\n    @patch('builtins.input', return_value='Pierre')\n    def test_input_pierre(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 1)\n        assert len(output) == 1, \"Votre programme n'affiche rien\"\n        assert output[0] == 'Bonjour Pierre, comment allez-vous ?', \"Le programme n'affiche pas le bon texte\"\n\n    @patch('builtins.input', return_value='Jean')\n    def test_input_jean(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 1)\n        assert len(output) == 1, \"Votre programme n'affiche rien\"\n        assert output[0] == 'Bonjour Jean, comment allez-vous ?', \"Le programme n'affiche pas le bon texte\"\n\n    @patch('builtins.input', return_value='Roger')\n    def test_input_roger(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 1)\n        assert len(output) == 1, \"Votre programme n'affiche rien\"\n        assert output[0] == 'Bonjour Roger, comment allez-vous ?', \"Le programme n'affiche pas le bon texte\"\n",
        "solution": "print(\"Quel est votre nom ?\")\nname = input()\nprint(\"Bonjour %s, comment allez-vous ?\" % (name))\n",
        "template_regions": [
          ""
        ],
        "template_regions_rw": [
          0
        ],
        "difficulty": 0,
        "score": 0,
        "creation_date": "2020-02-28T12:32:53.135Z"
      },
      {
        "sequence_id": 3,
        "title": "Évaluation d'une expression et affectation du résultat",
        "lang": "python",
        "instructions": "Écrire un programme qui initialise deux variables entières x et y à l'aide de la saisie utilisateur puis qui affiche le résultat du produit sous la forme `2 x 3 = 6` si x = 2 et y = 3.\n\nDans une première version, utiliser une variable intermédiaire z pour stocker le résultat avant de l'afficher.\n\nDans une seconde, se passer de la variable z.\n",
        "tests": "from unittest.mock import patch\nfrom unittest import TestCase\nfrom inspect import getmembers\n\nimport sys\nimport imp\nfrom contextlib import contextmanager\nfrom io import StringIO\n\n@contextmanager\ndef captured_output():\n    new_out = StringIO()\n    old_out = sys.stdout\n    try:\n        sys.stdout = new_out\n        yield sys.stdout\n    finally:\n        sys.stdout = old_out\n\ndef load_module():\n    if 'moduletotest' in sys.modules:\n        imp.reload(sys.modules['moduletotest'])\n    else:\n        import moduletotest\n\ndef get_cleaned_output(out, lines, check = False):\n    output = out.getvalue().strip()\n    l = output.split('\\n')\n    if check == True:\n        assert len(l[-lines:]) == lines, \"Pas assez de lignes affichées !\"\n    return l[-lines:]\n\nclass Test(TestCase):\n    @patch('builtins.input', side_effect=['2', '3'])\n    def test_input_x_and_y_exists(self, input):\n        with captured_output() as out:\n            load_module()\n        members = getmembers(sys.modules['moduletotest'])\n        x = [item for item in members if item[0] == 'x']\n        assert len(x) == 1, \"'x' n'existe pas\"\n        assert isinstance(x[0][1], int), \"'x' n'est pas de type Number\"\n        assert x[0][1] == 2, \"'x' n'a pas la valeur 2\"\n\n        y = [item for item in members if item[0] == 'y']\n        assert len(y) == 1, \"'y' n'eyiste pas\"\n        assert isinstance(y[0][1], int), \"'y' n'est pas de type Number\"\n        assert y[0][1] == 3, \"'y' n'a pas la valeur 3\"\n\n    @patch('builtins.input', side_effect=['2', '3'])\n    def test_input_2_3(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 1)\n        assert len(output) == 1, \"Le programme n'affiche rien\"\n        assert output[0] != 'x x y = z', \"Affichez le contenu des variables plutôt que leur nom\"\n        assert output[0] == '2 x 3 = 6', \"Le programme n'affiche pas la bonne opération\"\n\n    @patch('builtins.input', side_effect=['5', '7'])\n    def test_input_5_7(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 1)\n        assert len(output) == 1, \"Le programme n'affiche rien\"\n        assert output[0] != 'x x y = z', \"Affichez le contenu des variables plutôt que leur nom\"\n        assert output[0] == '5 x 7 = 35', \"Le programme n'affiche pas la bonne opération\"\n",
        "solution": "print(\"Saisissez x:\")\nx = int(input())\nprint(\"Saisissez y:\")\ny = int(input())\nz = x * y\nprint(\"%d x %d = %d\" % (x, y, z))\n",
        "template_regions": [
          ""
        ],
        "template_regions_rw": [
          0
        ],
        "difficulty": 0,
        "score": 0,
        "creation_date": "2020-02-28T12:32:53.135Z"
      },
      {
        "sequence_id": 4,
        "title": "Affectations successives",
        "lang": "python",
        "instructions": "Écrire un programme qui initialise deux variables entières n et p2 puis affiche les 6 premières puissances de 2\nsuccessives sous la forme suivante:\n```\n0:1 1:2 2:4 3:8 4:16 5:32\n```\n\nÀ chaque étape de votre algorithme, vous devez réutiliser les valeurs précédentes de n et p2 pour déterminer leurs\nvaleurs suivantes.\n",
        "tests": "from unittest.mock import patch\nfrom unittest import TestCase\nfrom inspect import getmembers\n\nimport sys\nimport re\nimport imp\nfrom contextlib import contextmanager\nfrom io import StringIO\n\n@contextmanager\ndef captured_output():\n    new_out = StringIO()\n    old_out = sys.stdout\n    try:\n        sys.stdout = new_out\n        yield sys.stdout\n    finally:\n        sys.stdout = old_out\n\ndef load_module():\n    if 'moduletotest' in sys.modules:\n        imp.reload(sys.modules['moduletotest'])\n    else:\n        import moduletotest\n\ndef get_cleaned_output(out, lines = 0):\n    output = out.getvalue().strip()\n    l = output.split('\\n')\n    return l # [-lines:]\n\nclass Test(TestCase):\n    def test_valeurs(self):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out)\n        assert len(output) > 0, \"Votre programme n'affiche rien\"\n        assert len(output) < 2, \"Votre programme affiche trop de lignes.\\n \\\n                Pour que print() ne retourne pas à la ligne,\\n \\\n                utilisez la syntaxe print('votre chaîne de caractères', end='')\"\n        output = output[0]\n        assert bool(re.match(r'[0-9]+ : [0-9]+', output)) == False, \"Enlevez les espaces autour du ':'\"\n        assert bool(re.match(r'^([0-9]+:[0-9]+[ ]?)+$', output)) == True, \"Vous ne respectez pas le format attentu: X:Y Z:T, pas d'espace autour du ':' et un seul espace entre deux blocs\"\n        assert '6:64' not in output, \"Vous êtes allés trop loin, arrêtez-vous à la 6e occurence\"\n        assert '5:32' in output, \"Vous n'allez pas assez loin, arrêtez-vous à la 6e occurence\"\n        assert '0:1' in output, \"Vous ne commencez pas à zéro\"\n        assert output == '0:1 1:2 2:4 3:8 4:16 5:32', \"La sortie n'est pas celle attendue\"\n\n\n",
        "solution": "n = 0\np2 = 1\nprint('%d:%d ' % (n, p2), end='')\nn = n + 1\np2 = p2 * 2\nprint('%d:%d ' % (n, p2), end='')\nn = n + 1\np2 = p2 * 2\nprint('%d:%d ' % (n, p2), end='')\nn = n + 1\np2 = p2 * 2\nprint('%d:%d ' % (n, p2), end='')\nn = n + 1\np2 = p2 * 2\nprint('%d:%d ' % (n, p2), end='')\nn = n + 1\np2 = p2 * 2\nprint('%d:%d ' % (n, p2), end='')\n",
        "template_regions": [
          ""
        ],
        "template_regions_rw": [
          0
        ],
        "difficulty": 0,
        "score": 0,
        "creation_date": "2020-02-28T12:32:53.136Z"
      },
      {
        "sequence_id": 5,
        "title": "Transposition",
        "lang": "python",
        "instructions": "La transposition consiste à échanger le contenu de deux ou plusieurs variables, que ce soient des entiers ou des chaînes de caractères.\n\na) Explorer toutes les manières de transposer les valeurs de deux variables x et y saisies par l'utilisateur. \n\nL'utilisateur doit d'abord saisir une valeur pour x puis pour y.\n\nb) Concevoir une technique de rotation des valeurs sur une série de 5 variables a, b, c, d, e saisies par l'utilisateur dans l'ordre alphabétique.\n\nUtiliser cette technique pour effectuer 7 cycles dans le sens a -> b (b prend la valeur de a), b -> c (c prend la valeur de b), etc.\n\nEx: (1, 2, 3, 4, 5) produit (4, 5, 1, 2, 3)\n\n**NOTE**: Il existe une méthode propre à Python.\n\n**NOTE2**: écrivez les deux parties de l'exercice dans le même fichier, l'une à la suite de l'autre\n",
        "tests": "from unittest.mock import patch\nfrom unittest import TestCase\nfrom inspect import getmembers\n\nimport sys\nimport imp\nfrom contextlib import contextmanager\nfrom io import StringIO\n\n@contextmanager\ndef captured_output():\n    new_out = StringIO()\n    old_out = sys.stdout\n    try:\n        sys.stdout = new_out\n        yield sys.stdout\n    finally:\n        sys.stdout = old_out\n\ndef load_module():\n    if 'moduletotest' in sys.modules:\n        imp.reload(sys.modules['moduletotest'])\n    else:\n        import moduletotest\n\ndef check_value(var, value):\n    members = getmembers(sys.modules['moduletotest'])\n    elem = [item for item in members if item[0] == var]\n    assert len(elem) == 1, \"'%s' n'existe pas\" % (var)\n    assert type(elem[0][1]) is str, \"la valeur d'entrée n'est pas forcément un nombre, ne la convertissez pas en int !\"\n    assert elem[0][1] == value, \"'%s' n'a pas la valeur '%s'\" % (var, value)\n\n\nclass Test(TestCase):\n    @patch('builtins.input', side_effect=['5', '6', '', '', '', '', ''])\n    def test_transposition_a_5_6(self, input):\n        with captured_output() as out:\n            load_module()\n        check_value('x', '6')\n        check_value('y', '5')\n\n    @patch('builtins.input', side_effect=['5', '6', '', '', '', '', ''])\n    def test_transposition_a_5_6(self, input):\n        with captured_output() as out:\n            load_module()\n        check_value('x', '6')\n        check_value('y', '5')\n\n    @patch('builtins.input', side_effect=['bonjour', 'au revoir', '', '', '', '', ''])\n    def test_transposition_a_bonjour_au_revoir(self, input):\n        with captured_output() as out:\n            load_module()\n        check_value('x', 'au revoir')\n        check_value('y', 'bonjour')\n\n    @patch('builtins.input', side_effect=['', '', '1', '2', '3', '4', '5'])\n    def test_transposition_b_1_2_3_4_5(self, input):\n        with captured_output() as out:\n            load_module()\n        check_value('a', '4')\n        check_value('b', '5')\n        check_value('c', '1')\n        check_value('d', '2')\n        check_value('e', '3')\n\n    @patch('builtins.input', side_effect=['', '', \"j'\", 'effectue', 'une', 'rotation', '.'])\n    def test_transposition_b_j_effectue_une_rotation(self, input):\n        with captured_output() as out:\n            load_module()\n        check_value('a', 'rotation')\n        check_value('b', '.')\n        check_value('c', \"j'\")\n        check_value('d', 'effectue')\n        check_value('e', 'une')\n",
        "solution": "print('valeur de x ?')\nx = input()\nprint('valeur de y ?')\ny = input()\n\nz = x\nx, y = y, x\n\nprint(\"a ?\")\na = input()\nprint(\"b ?\")\nb = input()\nprint(\"c ?\")\nc = input()\nprint(\"d ?\")\nd = input()\nprint(\"e ?\")\ne = input()\n\nb, c, d, e, a = a, b, c, d, e\nb, c, d, e, a = a, b, c, d, e\nb, c, d, e, a = a, b, c, d, e\nb, c, d, e, a = a, b, c, d, e\nb, c, d, e, a = a, b, c, d, e\nb, c, d, e, a = a, b, c, d, e\nb, c, d, e, a = a, b, c, d, e\n",
        "template_regions": [
          ""
        ],
        "template_regions_rw": [
          0
        ],
        "difficulty": 0,
        "score": 0,
        "creation_date": "2020-02-28T12:32:53.136Z"
      },
      {
        "sequence_id": 6,
        "title": "Fibonacci",
        "lang": "python",
        "instructions": "Écrire un programme qui affiche les 10 premiers termes de la suite de Fibonacci en n'utilisant pour cela que deux\nvariables. Chaque terme doit être affiché sur une ligne séparée.\n",
        "tests": "from unittest.mock import patch\nfrom unittest import TestCase\nfrom inspect import getmembers\n\nimport sys\nimport imp\nfrom contextlib import contextmanager\nfrom io import StringIO\n\n@contextmanager\ndef captured_output():\n    new_out = StringIO()\n    old_out = sys.stdout\n    try:\n        sys.stdout = new_out\n        yield sys.stdout\n    finally:\n        sys.stdout = old_out\n\ndef load_module():\n    if 'moduletotest' in sys.modules:\n        imp.reload(sys.modules['moduletotest'])\n    else:\n        import moduletotest\n\ndef check_value(var, value):\n    members = getmembers(sys.modules['moduletotest'])\n    elem = [item for item in members if item[0] == var]\n    assert len(elem) == 1, \"'%s' n'existe pas\" % (var)\n    assert elem[0][1] == value, \"'%s' n'a pas la valeur '%s'\" % (var, value)\n\ndef get_userdefined_variables():\n    return [item for item in dir(sys.modules['moduletotest']) if not item.startswith(\"__\")]\n\ndef get_cleaned_output(out, lines = 0):\n    output = out.getvalue().strip()\n    l = output.split('\\n')\n    return l # [-lines:]\n\nwith captured_output() as out:\n    load_module()\n\nclass Test(TestCase):\n    def test_seulement_deux_variables(self):\n        variables = get_userdefined_variables()\n        assert len(variables) >= 2, \"Moins de deux variables sont définies\"\n        assert len(variables) <= 2, \"Plus de deux variables sont définies\"\n\n    def test_n_0(self):\n        output = get_cleaned_output(out)\n        assert len(output) >= 1, \"Il n'y a pas assez de termes affichés\"\n        assert '0' == output[0], \"Le premier terme n'est pas 0\"\n\n    def test_n_1(self):\n        output = get_cleaned_output(out)\n        assert len(output) >= 2, \"Il n'y a pas assez de termes affichés\"\n        assert '1' == output[1], \"Le deuxième terme n'est pas 1\"\n\n    def test_n_2(self):\n        output = get_cleaned_output(out)\n        assert len(output) >= 3, \"Il n'y a pas assez de termes affichés\"\n        assert '1' == output[2], \"Le troisième terme n'est pas 1\"\n\n    def test_n_3(self):\n        output = get_cleaned_output(out)\n        assert len(output) >= 4, \"Il n'y a pas assez de termes affichés\"\n        assert '2' == output[3], \"Le quatrième terme n'est pas 2\"\n\n    def test_n_4(self):\n        output = get_cleaned_output(out)\n        assert len(output) >= 5, \"Il n'y a pas assez de termes affichés\"\n        assert '3' == output[4], \"Le cinquième terme n'est pas 3\"\n\n    def test_n_5(self):\n        output = get_cleaned_output(out)\n        assert len(output) >= 6, \"Il n'y a pas assez de termes affichés\"\n        assert '5' == output[5], \"Le sixième terme n'est pas 5\"\n\n\n    def test_n_6(self):\n        output = get_cleaned_output(out)\n        assert len(output) >= 7, \"Il n'y a pas assez de termes affichés\"\n        assert '8' == output[6], \"Le septième terme n'est pas 8\"\n\n    def test_n_7(self):\n        output = get_cleaned_output(out)\n        assert len(output) >= 8, \"Il n'y a pas assez de termes affichés\"\n        assert '13' == output[7], \"Le huitième terme n'est pas 13\"\n\n    def test_n_8(self):\n        output = get_cleaned_output(out)\n        assert len(output) >= 9, \"Il n'y a pas assez de termes affichés\"\n        assert '21' == output[8], \"Le neuvième terme n'est pas 21\"\n\n    def test_n_9(self):\n        output = get_cleaned_output(out)\n        assert len(output) >= 10, \"Il n'y a pas assez de termes affichés\"\n        assert '34' == output[9], \"Le dixième terme n'est pas 34\"\n",
        "solution": "prec = 0\nprint(prec)\nactu = 1\nprint(actu)\nprec = prec + actu\nprint(prec)\nactu = prec + actu\nprint(actu)\nprec = prec + actu\nprint(prec)\nactu = prec + actu\nprint(actu)\nprec = prec + actu\nprint(prec)\nactu = prec + actu\nprint(actu)\nprec = prec + actu\nprint(prec)\nactu = prec + actu\nprint(actu)\n",
        "template_regions": [
          ""
        ],
        "template_regions_rw": [
          0
        ],
        "difficulty": 0,
        "score": 0,
        "creation_date": "2020-02-28T12:32:53.137Z"
      }
    ]
  },
  {
    "name": "TP2",
    "exercises": [
      {
        "sequence_id": 0,
        "title": "Comparaisons",
        "lang": "python",
        "instructions": "a) Concevoir un algorithme qui demande à l'utilisateur de saisir un entier `x`, et qui affiche la valeur de \ncet entier suivie du texte ` est pair` si l'entier est pair et du  texte ` est impair` sinon.\n\nb) Concevoir un algorithme qui demande à l'utilisateur de saisir deux entiers `y` et `z`, et qui indique par\nun message si `y` est supérieur ou inférieur à `z`.\n\nLes messages sont formatés de la manière suivante:\n```\n{y} {opérateur} {z}\n```\n\n- où {y} et {z} correspondent respectivement aux valeurs de y et de z\n- où {opérateur} correspond au comparateur correspondant\n\n**NOTE:** implémentez les deux parties de l'exercice à la suite l'une de l'autre dans le même fichier.\n\n",
        "tests": "from unittest.mock import patch\nfrom unittest import TestCase\nfrom inspect import getmembers\n\nimport sys\nimport imp\nfrom contextlib import contextmanager\nfrom io import StringIO\n\n@contextmanager\ndef captured_output():\n    new_out = StringIO()\n    old_out = sys.stdout\n    try:\n        sys.stdout = new_out\n        yield sys.stdout\n    finally:\n        sys.stdout = old_out\n\ndef load_module():\n    if 'moduletotest' in sys.modules:\n        imp.reload(sys.modules['moduletotest'])\n    else:\n        import moduletotest\n\ndef check_value(var, value):\n    members = getmembers(sys.modules['moduletotest'])\n    elem = [item for item in members if item[0] == var]\n    assert len(elem) == 1, \"'%s' n'existe pas\" % (var)\n    assert elem[0][1] == value, \"'%s' n'a pas la valeur '%s'\" % (var, value)\n\ndef get_userdefined_variables():\n    return [item for item in dir(sys.modules['moduletotest']) if not item.startswith(\"__\")]\n\ndef get_cleaned_output(out, lines = -1):\n    output = out.getvalue().strip()\n    l = output.split('\\n')\n    if lines == -1:\n        return l\n    else:\n        return l[-lines:]\n\nclass Test(TestCase):\n    @patch('builtins.input', side_effect=['1000000', '0', '0'])\n    def test_pair_1(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out)\n        assert len(output) > 0, \"Le programme n'affiche rien !\"\n        assert  '1000000 est pair' in output, \"l'affichage ne correspond pas !\"\n\n    @patch('builtins.input', side_effect=['2483904', '0', '0'])\n    def test_pair_2(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out)\n        assert len(output) > 0, \"Le programme n'affiche rien !\"\n        assert '2483904 est pair' in output, \"l'affichage ne correspond pas !\"\n\n    @patch('builtins.input', side_effect=['1235', '0', '0'])\n    def test_impair_1(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out)\n        assert len(output) > 0, \"Le programme n'affiche rien !\"\n        assert '1235 est impair' in output, \"l'affichage ne correspond pas !\"\n\n    @patch('builtins.input', side_effect=['343741', '0', '0'])\n    def test_impair_2(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out)\n        assert len(output) > 0, \"Le programme n'affiche rien !\"\n        assert '343741 est impair' in output, \"l'affichage ne correspond pas !\"\n\n    @patch('builtins.input', side_effect=['343741', '3', '2'])\n    def test_y_gt_z(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out)\n        assert len(output) > 0, \"Le programme n'affiche rien !\"\n        assert '3 > 2' in output, \"l'affichage ne correspond pas !\"\n\n    @patch('builtins.input', side_effect=['343741', '49094090', '58493899'])\n    def test_y_lt_z(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out)\n        assert len(output) > 0, \"Le programme n'affiche rien !\"\n        assert '49094090 < 58493899' in output, \"l'affichage ne correspond pas !\"\n\n    @patch('builtins.input', side_effect=['343741', '49494', '49494'])\n    def test_y_eq_z(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out)\n        assert len(output) > 0, \"Le programme n'affiche rien !\"\n        assert '49494 = 49494' in output, \"l'affichage ne correspond pas !\"\n",
        "solution": "print('x ?')\nx = int(input())\n\nif x % 2 == 0:\n    print(\"%d est pair\" % (x))\nelse:\n    print(\"%d est impair\" % (x))\n\nprint('y?')\ny = int(input())\nprint('z?')\nz = int(input())\n\nop = '='\n\nif y < z:\n    op = '<'\nelif y > z:\n    op = '>'\n\nprint(\"%d %s %d\" % (y, op, z))\n",
        "template_regions": [
          ""
        ],
        "template_regions_rw": [
          0
        ],
        "difficulty": 0,
        "score": 0,
        "creation_date": "2020-02-28T12:32:53.137Z"
      },
      {
        "sequence_id": 1,
        "title": "Intervalle",
        "lang": "python",
        "instructions": "Concevoir un algorithme qui attend la saisie par l'utilisateur de deux entiers `a` et `b`, s'arrête avec le message d'erreur \"{a} est supérieur à {b}, arrêt.\" si a > b (remplacer {a} et {b} par leurs valeurs respectives), et demande sinon à l'utilisateur de saisir un entier `y` puis indique par un message si `y` est dans l'intervalle [a, b] ou non.\n\n- Si y est dans l'intervalle, le message est `{y} est dans l'intervalle [{a}, {b}]`\n- Si y n'est pas dans l'intervalle, le message est `{y} n'est pas dans l'intervalle [{a}, {b}]`\n",
        "tests": "from unittest.mock import patch\nfrom unittest import TestCase\nfrom inspect import getmembers\n\nimport sys\nimport imp\nfrom contextlib import contextmanager\nfrom io import StringIO\n\n@contextmanager\ndef captured_output():\n    new_out = StringIO()\n    old_out = sys.stdout\n    try:\n        sys.stdout = new_out\n        yield sys.stdout\n    finally:\n        sys.stdout = old_out\n\ndef load_module():\n    if 'moduletotest' in sys.modules:\n        imp.reload(sys.modules['moduletotest'])\n    else:\n        import moduletotest\n\ndef check_value(var, value):\n    members = getmembers(sys.modules['moduletotest'])\n    elem = [item for item in members if item[0] == var]\n    assert len(elem) == 1, \"'%s' n'existe pas\" % (var)\n    assert elem[0][1] == value, \"'%s' n'a pas la valeur '%s'\" % (var, value)\n\ndef get_userdefined_variables():\n    return [item for item in dir(sys.modules['moduletotest']) if not item.startswith(\"__\")]\n\ndef get_cleaned_output(out, lines):\n    output = out.getvalue().strip()\n    l = output.split('\\n')\n    return l[-lines:]\n\n\nclass Test(TestCase):\n    @patch('builtins.input', side_effect=['3', '2', '1'])\n    def test_message_erreur(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 1)\n        assert len(output) > 0, \"Le programme n'affiche rien\"\n        assert output[0] != '3 est supérieur à 2 , arrêt.', \"Enlevez l'espace avant la virgule, grâce à sep=''\"\n        assert output[0] == '3 est supérieur à 2, arrêt.', \"La sortie n'est pas celle attendue\"\n\n    @patch('builtins.input', side_effect=['2', '4', '3'])\n    def test_message_dans_intervalle_1(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 1)\n        assert len(output) > 0, \"Le programme n'affiche rien\"\n        assert output[0] == \"3 est dans l'intervalle [2, 4]\", \"La sortie n'est pas celle attendue\"\n\n    @patch('builtins.input', side_effect=['48', '59', '52'])\n    def test_message_dans_intervalle_2(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 1)\n        assert len(output) > 0, \"Le programme n'affiche rien\"\n        assert output[0] == \"52 est dans l'intervalle [48, 59]\", \"La sortie n'est pas celle attendue\"\n\n    @patch('builtins.input', side_effect=['79', '80', '80'])\n    def test_message_dans_intervalle_3(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 1)\n        assert len(output) > 0, \"Le programme n'affiche rien\"\n        assert output[0] == \"80 est dans l'intervalle [79, 80]\", \"La sortie n'est pas celle attendue\"\n\n    @patch('builtins.input', side_effect=['1200', '1300', '1200'])\n    def test_message_dans_intervalle_4(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 1)\n        assert len(output) > 0, \"Le programme n'affiche rien\"\n        assert output[0] == \"1200 est dans l'intervalle [1200, 1300]\", \"La sortie n'est pas celle attendue\"\n\n    @patch('builtins.input', side_effect=['99', '101', '98'])\n    def test_message_pas_dans_intervalle_1(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 1)\n        assert len(output) > 0, \"Le programme n'affiche rien\"\n        assert output[0] == \"98 n'est pas dans l'intervalle [99, 101]\", \"La sortie n'est pas celle attendue\"\n\n    @patch('builtins.input', side_effect=['99', '101', '102'])\n    def test_message_pas_dans_intervalle_2(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 1)\n        assert len(output) > 0, \"Le programme n'affiche rien\"\n        assert output[0] == \"102 n'est pas dans l'intervalle [99, 101]\", \"La sortie n'est pas celle attendue\"\n\n    @patch('builtins.input', side_effect=['99', '101', '102'])\n    def test_valeurs(self, input):\n        with captured_output() as out:\n            load_module()\n        check_value('a', 99)\n        check_value('b', 101)\n        check_value('y', 102)\n",
        "solution": "print('a ?')\na = int(input())\nprint('b ?')\nb = int(input())\n\nif a > b:\n    print(\"%d est supérieur à %d, arrêt.\" % (a, b))\nelse:\n    y = int(input(\"z ?\"))\n    if a <= y <= b:\n        print(\"%d est dans l'intervalle [%d, %d]\" % (y, a, b))\n    else:\n        print(\"%d n'est pas dans l'intervalle [%d, %d]\" % (y, a, b))\n",
        "template_regions": [
          ""
        ],
        "template_regions_rw": [
          0
        ],
        "difficulty": 0,
        "score": 0,
        "creation_date": "2020-02-28T12:32:53.137Z"
      },
      {
        "sequence_id": 2,
        "title": "Âge et sexe",
        "lang": "python",
        "instructions": "Concevoir un algorithme qui demande à l'utilisateur son nom, son année de naissance puis son sexe (H ou F), puis qui\naffiche un message qui salue l'utilisateur, indique son âge, en utilisant la première personne si\nl'utilisateur a moins de 16 ans, la troisième sinon, et enfin s'il est homme, garçon, femme ou fille.\n\nExemples:\n- Bonjour Bertrand, tu as 5 ans et tu es un garçon.\n- Bonjour Jasmine, tu as 15 ans et tu es une fille.\n- Bonjour Pierre, vous avez 50 ans et vous êtes un homme.\n- Bonjour Sophie, vous avez 16 ans et vous êtes une femme.\n",
        "tests": "from unittest.mock import patch\nfrom unittest import TestCase\nfrom inspect import getmembers\n\nimport sys\nimport imp\nfrom contextlib import contextmanager\nfrom io import StringIO\n\n@contextmanager\ndef captured_output():\n    new_out = StringIO()\n    old_out = sys.stdout\n    try:\n        sys.stdout = new_out\n        yield sys.stdout\n    finally:\n        sys.stdout = old_out\n\ndef load_module():\n    if 'moduletotest' in sys.modules:\n        imp.reload(sys.modules['moduletotest'])\n    else:\n        import moduletotest\n\ndef check_value(var, value):\n    members = getmembers(sys.modules['moduletotest'])\n    elem = [item for item in members if item[0] == var]\n    assert len(elem) == 1, \"'%s' n'existe pas\" % (var)\n    assert elem[0][1] == value, \"'%s' n'a pas la valeur '%s'\" % (var, value)\n\ndef get_userdefined_variables():\n    return [item for item in dir(sys.modules['moduletotest']) if not item.startswith(\"__\")]\n\ndef get_cleaned_output(out, lines):\n    output = out.getvalue().strip()\n    l = output.split('\\n')\n    return l[-lines:]\n\nclass Test(TestCase):\n    @patch('builtins.input', side_effect=['Paul', '2013', 'H'])\n    def test_homme_1(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 1)\n        assert len(output) > 0, \"Le programme n'affiche rien\"\n        assert output[0] == 'Bonjour Paul, tu as 5 ans et tu es un garçon.', \"La sortie du programme n'est pas celle attendue\"\n\n    @patch('builtins.input', side_effect=['Jean', '2003', 'H'])\n    def test_homme_2(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 1)\n        assert len(output) > 0, \"Le programme n'affiche rien\"\n        assert output[0] == 'Bonjour Jean, tu as 15 ans et tu es un garçon.', \"La sortie du programme n'est pas celle attendue\"\n\n    @patch('builtins.input', side_effect=['Michel', '1998', 'H'])\n    def test_homme_3(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 1)\n        assert len(output) > 0, \"Le programme n'affiche rien\"\n        assert output[0] == 'Bonjour Michel, vous avez 20 ans et vous êtes un homme.', \"La sortie du programme n'est pas celle attendue\"\n\n    @patch('builtins.input', side_effect=['Jacqueline', '1918', 'F'])\n    def test_femme_2(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 1)\n        assert len(output) > 0, \"Le programme n'affiche rien\"\n        assert output[0] == 'Bonjour Jacqueline, vous avez 100 ans et vous êtes une femme.', \"La sortie du programme n'est pas celle attendue\"\n\n    @patch('builtins.input', side_effect=['Patricia', '2000', 'F'])\n    def test_femme_3(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 1)\n        assert len(output) > 0, \"Le programme n'affiche rien\"\n        assert output[0] == 'Bonjour Patricia, vous avez 18 ans et vous êtes une femme.', \"La sortie du programme n'est pas celle attendue\"\n\n    @patch('builtins.input', side_effect=['Ange', '2005', 'F'])\n    def test_femme_4(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 1)\n        assert len(output) > 0, \"Le programme n'affiche rien\"\n        assert output[0] == 'Bonjour Ange, tu as 13 ans et tu es une fille.', \"La sortie du programme n'est pas celle attendue\"\n",
        "solution": "print('nom ?')\nname = input()\nprint('année ?')\nyear = int(input())\nprint('sexe ?')\nsex = input()\n\nprint(\"Bonjour %s, \" % (name), end='')\nyo = 2018 - year\n\nif yo < 16:\n    print(\"tu as %d ans et tu es \" % yo, end='')\n    if sex == 'H':\n        print(\"un garçon.\")\n    else:\n        print(\"une fille.\")\nelse:\n    print(\"vous avez %d ans et vous êtes \" % yo, end='')\n    if sex == 'H':\n        print(\"un homme.\")\n    else:\n        print(\"une femme.\")\n",
        "template_regions": [
          ""
        ],
        "template_regions_rw": [
          0
        ],
        "difficulty": 0,
        "score": 0,
        "creation_date": "2020-02-28T12:32:53.138Z"
      },
      {
        "sequence_id": 3,
        "title": "Conjonction, Disjonction, Exclusivité",
        "lang": "python",
        "instructions": "Concevoir un algorithme qui demande à l'utilisateur trois entiers `x`, `y`, et `z`, et qui affiche successivement:\n- \"True\" si x = y = z, \"False\" sinon;\n- \"True\" si deux au moins des trois variables sont égales, \"False\" sinon;\n- \"True\" si deux et seulement deux des trois variables sont égales, et \"False\" sinon.\n",
        "tests": "from unittest.mock import patch\nfrom unittest import TestCase\nfrom inspect import getmembers\n\nimport sys\nimport imp\nfrom contextlib import contextmanager\nfrom io import StringIO\n\n@contextmanager\ndef captured_output():\n    new_out = StringIO()\n    old_out = sys.stdout\n    try:\n        sys.stdout = new_out\n        yield sys.stdout\n    finally:\n        sys.stdout = old_out\n\ndef load_module():\n    if 'moduletotest' in sys.modules:\n        imp.reload(sys.modules['moduletotest'])\n    else:\n        import moduletotest\n\ndef check_value(var, value):\n    members = getmembers(sys.modules['moduletotest'])\n    elem = [item for item in members if item[0] == var]\n    assert len(elem) == 1, \"'%s' n'existe pas\" % (var)\n    assert elem[0][1] == value, \"'%s' n'a pas la valeur '%s'\" % (var, value)\n\ndef get_userdefined_variables():\n    return [item for item in dir(sys.modules['moduletotest']) if not item.startswith(\"__\")]\n\ndef get_cleaned_output(out, lines):\n    output = out.getvalue().strip()\n    l = output.split('\\n')\n    return l[-lines:]\n\nclass Test(TestCase):\n\n    lignes_affichees = ['1', '2', '3']\n    @patch('builtins.input', side_effect=lignes_affichees)\n    def test_lignes_affichees(self, input):\n        with captured_output() as out:\n            load_module()\n        l = get_cleaned_output(out, 3)\n        assert len(l) > 2, \"Vous n'affichez pas assez de texte !\"\n        assert l[0] == 'True' or l[0] == 'False', \"Vous affichez autre chose que True et False\"\n        assert l[1] == 'True' or l[1] == 'False', \"Vous affichez autre chose que True et False\"\n        assert l[2] == 'True' or l[2] == 'False', \"Vous affichez autre chose que True et False\"\n\n    conjonction_1 = ['1', '2', '3']\n    @patch('builtins.input', side_effect=conjonction_1)\n    def test_conjonction_1(self, input):\n        with captured_output() as out:\n            load_module()\n        l = get_cleaned_output(out, 3)\n        assert len(l) > 2, \"Vous n'affichez pas assez de texte !\"\n        assert l[0] == 'False', \\\n            '%d != %d et %d != %d, la conjonction doit retourner False' % \\\n            (conjonction_1[0], conjonction_1[1], conjonction_1[1], conjonction_1[2])\n\n    conjonction_2 = ['3304', '39843', '23290']\n    @patch('builtins.input', side_effect=conjonction_2)\n    def test_conjonction_2(self, input):\n        with captured_output() as out:\n            load_module()\n        l = get_cleaned_output(out, 3)\n        assert len(l) > 2, \"Vous n'affichez pas assez de texte !\"\n        assert l[0] == 'False', \\\n            '%d != %d et %d != %d, la conjonction doit retourner False' % \\\n            (conjonction_2[0], conjonction_2[1], conjonction_2[1], conjonction_2[2])\n\n    conjonction_3 = ['100', '100', '100']\n    @patch('builtins.input', side_effect=conjonction_3)\n    def test_conjonction_3(self, input):\n        with captured_output() as out:\n            load_module()\n        l = get_cleaned_output(out, 3)\n        assert len(l) > 2, \"Vous n'affichez pas assez de texte !\"\n        assert l[0] == 'True', \\\n            'les trois valeurs sont identiques, la conjonction doit retourner True'\n\n    conjonction_4 = ['2000', '2000', '2000']\n    @patch('builtins.input', side_effect=conjonction_4)\n    def test_conjonction_4(self, input):\n        with captured_output() as out:\n            load_module()\n        l = get_cleaned_output(out, 3)\n        assert len(l) > 2, \"Vous n'affichez pas assez de texte !\"\n        assert l[0] == 'True', \\\n            'les trois valeurs sont identiques, la conjonction doit retourner True'\n\n    disjonction_1 = ['1', '2', '3']\n    @patch('builtins.input', side_effect=disjonction_1)\n    def test_disjonction_1(self, input):\n        with captured_output() as out:\n            load_module()\n        l = get_cleaned_output(out, 3)\n        assert len(l) > 2, \"Vous n'affichez pas assez de texte !\"\n        assert l[1] == 'False', \\\n            '%d != %d et %d != %d, la disjonction doit retourner False' % \\\n            (disjonction_1[0], disjonction_1[1], disjonction_1[1], disjonction_1[2])\n\n    disjonction_2 = ['3304', '39843', '23290']\n    @patch('builtins.input', side_effect=disjonction_2)\n    def test_disjonction_2(self, input):\n        with captured_output() as out:\n            load_module()\n        l = get_cleaned_output(out, 3)\n        assert len(l) > 2, \"Vous n'affichez pas assez de texte !\"\n        assert l[1] == 'False', \\\n            '%d != %d et %d != %d, la disjonction doit retourner False' % \\\n            (disjonction_2[0], disjonction_2[1], disjonction_2[1], disjonction_2[2])\n\n    disjonction_3 = ['100', '100', '100']\n    @patch('builtins.input', side_effect=disjonction_3)\n    def test_disjonction_3(self, input):\n        with captured_output() as out:\n            load_module()\n        l = get_cleaned_output(out, 3)\n        assert len(l) > 2, \"Vous n'affichez pas assez de texte !\"\n        assert l[1] == 'True', 'Les trois valeurs sont identiques, la disjonction doit retourner True'\n\n    disjonction_4 = ['2000', '2000', '2000']\n    @patch('builtins.input', side_effect=disjonction_4)\n    def test_disjonction_4(self, input):\n        with captured_output() as out:\n            load_module()\n        l = get_cleaned_output(out, 3)\n        assert len(l) > 2, \"Vous n'affichez pas assez de texte !\"\n        assert l[1] == 'True', \\\n            'Les trois valeurs sont identiques, la disjonction doit retourner True'\n    disjonction_5 = ['2000', '2000', '1990']\n    @patch('builtins.input', side_effect=disjonction_5)\n    def test_disjonction_5(self, input):\n        with captured_output() as out:\n            load_module()\n        l = get_cleaned_output(out, 3)\n        assert len(l) > 2, \"Vous n'affichez pas assez de texte !\"\n        assert l[1] == 'True', \\\n            'Deux des trois valeurs sont identiques, la disjonction doit retourner True'\n\n    disjonction_6 = ['2000', '1990', '1990']\n    @patch('builtins.input', side_effect=disjonction_6)\n    def test_disjonction_6(self, input):\n        with captured_output() as out:\n            load_module()\n        l = get_cleaned_output(out, 3)\n        assert len(l) > 2, \"Vous n'affichez pas assez de texte !\"\n        assert l[1] == 'True', \\\n            'Deux des trois valeurs sont identiques, la disjonction doit retourner True'\n\n    disjonction_7 = ['1990', '2000', '1990']\n    @patch('builtins.input', side_effect=disjonction_7)\n    def test_disjonction_7(self, input):\n        with captured_output() as out:\n            load_module()\n        l = get_cleaned_output(out, 3)\n        assert len(l) > 2, \"Vous n'affichez pas assez de texte !\"\n        assert l[1] == 'True', \\\n            'Deux des trois valeurs sont identiques, la disjonction doit retourner True'\n\n    exclusivite_1 = ['1', '2', '3']\n    @patch('builtins.input', side_effect=exclusivite_1)\n    def test_exclusivite_1(self, input):\n        with captured_output() as out:\n            load_module()\n        l = get_cleaned_output(out, 3)\n        assert len(l) > 2, \"Vous n'affichez pas assez de texte !\"\n        assert l[2] == 'False', \\\n            '%d != %d et %d != %d, l\\'exclusivité doit retourner False' % \\\n            (exclusivite_1[0], exclusivite_1[1], exclusivite_1[1], exclusivite_1[2])\n\n    exclusivite_2 = ['3304', '39843', '23290']\n    @patch('builtins.input', side_effect=exclusivite_2)\n    def test_exclusivite_2(self, input):\n        with captured_output() as out:\n            load_module()\n        l = get_cleaned_output(out, 3)\n        assert len(l) > 2, \"Vous n'affichez pas assez de texte !\"\n        assert l[2] == 'False', \\\n            '%d != %d et %d != %d, l\\'exclusivité doit retourner False' % \\\n            (exclusivite_2[0], exclusivite_2[1], exclusivite_2[1], exclusivite_2[2])\n\n    exclusivite_3 = ['100', '100', '100']\n    @patch('builtins.input', side_effect=exclusivite_3)\n    def test_exclusivite_3(self, input):\n        with captured_output() as out:\n            load_module()\n        l = get_cleaned_output(out, 3)\n        assert len(l) > 2, \"Vous n'affichez pas assez de texte !\"\n        assert l[2] == 'False', 'Les trois valeurs sont identiques, l\\'exclusivité doit retourner False'\n\n    exclusivite_4 = ['2000', '2000', '2000']\n    @patch('builtins.input', side_effect=exclusivite_4)\n    def test_exclusivite_4(self, input):\n        with captured_output() as out:\n            load_module()\n        l = get_cleaned_output(out, 3)\n        assert len(l) > 2, \"Vous n'affichez pas assez de texte !\"\n        assert l[2] == 'False', \\\n            'Les trois valeurs sont identiques, l\\'exclusivité doit retourner False'\n\n    exclusivite_5 = ['2000', '2000', '1990']\n    @patch('builtins.input', side_effect=exclusivite_5)\n    def test_exclusivite_5(self, input):\n        with captured_output() as out:\n            load_module()\n        l = get_cleaned_output(out, 3)\n        assert len(l) > 2, \"Vous n'affichez pas assez de texte !\"\n        assert l[2] == 'True', \\\n            'Deux des trois valeurs sont identiques, l\\'exclusivité doit retourner True'\n\n    exclusivite_6 = ['2000', '1990', '1990']\n    @patch('builtins.input', side_effect=exclusivite_6)\n    def test_exclusivite_6(self, input):\n        with captured_output() as out:\n            load_module()\n        l = get_cleaned_output(out, 3)\n        assert len(l) > 2, \"Vous n'affichez pas assez de texte !\"\n        assert l[2] == 'True', \\\n            'Deux des trois valeurs sont identiques, l\\'exclusivité doit retourner True'\n\n    exclusivite_7 = ['1990', '2000', '1990']\n    @patch('builtins.input', side_effect=exclusivite_7)\n    def test_exclusivite_7(self, input):\n        with captured_output() as out:\n            load_module()\n        l = get_cleaned_output(out, 3)\n        assert len(l) > 2, \"Vous n'affichez pas assez de texte !\"\n        assert l[2] == 'True', \\\n            'Deux des trois valeurs sont identiques, l\\'exclusivité doit retourner True'\n",
        "solution": "print('x ?')\nx = int(input())\nprint('y ?')\ny = int(input())\nprint('z ?')\nz = int(input())\n\n# Conjonction\nif x == y and y == z:\n    print(\"True\")\nelse:\n    print(\"False\")\n\n# Disjonction\nif x == y or y == z or x == z:\n    print(\"True\")\nelse:\n    print(\"False\")\n\n# Exclusivité\nif (x == y or y == z or x == z) and (x != y or y != z or x != z):\n    print(\"True\")\nelse:\n    print(\"False\")\n",
        "template_regions": [
          ""
        ],
        "template_regions_rw": [
          0
        ],
        "difficulty": 0,
        "score": 0,
        "creation_date": "2020-02-28T12:32:53.138Z"
      },
      {
        "sequence_id": 4,
        "title": "Calculatrice",
        "lang": "python",
        "instructions": "Concevoir un algorithme qui demande à l'utilisateur deux opérandes `x` et `y` entières, puis un opérateur `op` (\"\\*\", \"/\",\"+\", ou \"-\"). Suivant l'opérateur, effectuer puis afficher l'opération, par exemple '2 x 3 = 6'. Si l'opérateur est est \"/\" et que `y` vaut 0, ne pas effectuer l'opération et afficher le message d'erreur \"Division par zéro!\". Si le résultat n'est pas un entier, n'afficher que la partie entière.\n\n",
        "tests": "from unittest.mock import patch\nfrom unittest import TestCase\nfrom inspect import getmembers\n\nimport sys\nimport imp\nfrom contextlib import contextmanager\nfrom io import StringIO\n\n@contextmanager\ndef captured_output():\n    new_out = StringIO()\n    old_out = sys.stdout\n    try:\n        sys.stdout = new_out\n        yield sys.stdout\n    finally:\n        sys.stdout = old_out\n\ndef load_module():\n    if 'moduletotest' in sys.modules:\n        imp.reload(sys.modules['moduletotest'])\n    else:\n        import moduletotest\n\ndef check_value(var, value):\n    members = getmembers(sys.modules['moduletotest'])\n    elem = [item for item in members if item[0] == var]\n    assert len(elem) == 1, \"'%s' n'existe pas\" % (var)\n    assert elem[0][1] == value, \"'%s' n'a pas la valeur '%s'\" % (var, value)\n\ndef get_userdefined_variables():\n    return [item for item in dir(sys.modules['moduletotest']) if not item.startswith(\"__\")]\n\ndef assert_equation(output, data):\n    if data[2] == '/' and data[1] == '0':\n        assert output == 'Division par zéro!'\n    else:\n        assert output == \"%s %s %s = %d\" % \\\n                (data[0], data[2], data[1], int(eval(\"%s %s %s\" % (data[0], data[2], data[1]))))\n\ndef get_cleaned_output(out, lines, check = False):\n    output = out.getvalue().strip()\n    l = output.split('\\n')\n    if check == True:\n        assert len(l[-lines:]) == lines, \"Pas assez de lignes affichées !\"\n    return l[-lines:]\n\nclass Test(TestCase):\n    in_1 = ['1', '2', '+']\n    @patch('builtins.input', side_effect=in_1)\n    def test_plus_1(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 1, True)\n        assert_equation(output[0], self.in_1)\n\n    in_2 = ['1000000', '843984398349', '+']\n    @patch('builtins.input', side_effect=in_2)\n    def test_plus_2(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 1, True)\n        assert_equation(output[0], self.in_2)\n\n    in_3 = ['200', '347834738', '-']\n    @patch('builtins.input', side_effect=in_3)\n    def test_moins_1(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 1, True)\n        assert_equation(output[0], self.in_3)\n\n    in_4 = ['8485904854095', '4834784', '-']\n    @patch('builtins.input', side_effect=in_4)\n    def test_moins_2(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 1, True)\n        assert_equation(output[0], self.in_4)\n\n    in_5 = ['238293', '-3490', '*']\n    @patch('builtins.input', side_effect=in_5)\n    def test_multiplie_1(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 1, True)\n        assert_equation(output[0], self.in_5)\n\n    in_6 = ['8398439084', '0', '*']\n    @patch('builtins.input', side_effect=in_6)\n    def test_multiplie_2(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 1, True)\n        assert_equation(output[0], self.in_6)\n\n    in_7 = ['8398439084', '0', '/']\n    @patch('builtins.input', side_effect=in_7)\n    def test_divise_1(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 1, True)\n        assert_equation(output[0], self.in_7)\n\n    in_8 = ['1399084', '-3489', '/']\n    @patch('builtins.input', side_effect=in_8)\n    def test_divise_2(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 1, True)\n        assert_equation(output[0], self.in_8)\n\n    in_9 = ['384', '4374', '/']\n    @patch('builtins.input', side_effect=in_9)\n    def test_divise_3(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 1, True)\n        assert_equation(output[0], self.in_9)\n",
        "solution": "print('x ?')\nx = int(input())\nprint('y ?')\ny = int(input())\nprint('z ?')\nop = input('z ?')\n\nif op == '+':\n    print('%d + %d = %d' % (x, y, x + y))\nelif op == '-':\n    print('%d - %d = %d' % (x, y, x - y))\nelif op == '*':\n    print('%d * %d = %d' % (x, y, x * y))\nelif op == '/':\n    if y == 0:\n        print(\"Division par zéro!\")\n    else:\n        print('%d / %d = %d' % (x, y, x / y))\n",
        "template_regions": [
          ""
        ],
        "template_regions_rw": [
          0
        ],
        "difficulty": 0,
        "score": 0,
        "creation_date": "2020-02-28T12:32:53.138Z"
      },
      {
        "sequence_id": 5,
        "title": "Jeu de la vie",
        "lang": "python",
        "instructions": "Soit un carré composé de 3x3 cellules qui peuvent être vivantes ou mortes. On nomme les 8 cellules de bord par les points cardinaux.\nPar exemple, la cellule `sw` est la cellule située au sud-ouest, la cellule `ee` celle qui est située plein est.\nLa cellule centrale est nommée `c`.\n\nLa règle du jeu de la vie stipule qu'à partir d'un état de cellules donné, à la génération suivante:\n- si une cellule est morte et est entourée par 3 cellules vivantes, alors elle devient vivante.\n- si une cellule est vivante, elle ne survit que si elle est entourée de deux ou trois cellules vivantes.\n\nConcevoir un programme qui demande à l'utilisateur de saisir l'état de chacune des cellules dans l'ordre suivant:\nnw, nn, ne,\nww, c, ee,\nsw, ss, se; avec pour valeur True si la cellule est vivante, False sinon.\n\nLe programme doit afficher True si la cellule centrale est vivante, False sinon.\n",
        "tests": "from unittest.mock import patch\nfrom unittest import TestCase\nfrom inspect import getmembers\n\nimport sys\nimport imp\nfrom contextlib import contextmanager\nfrom io import StringIO\n\n@contextmanager\ndef captured_output():\n    new_out = StringIO()\n    old_out = sys.stdout\n    try:\n        sys.stdout = new_out\n        yield sys.stdout\n    finally:\n        sys.stdout = old_out\n\ndef load_module():\n    if 'moduletotest' in sys.modules:\n        imp.reload(sys.modules['moduletotest'])\n    else:\n        import moduletotest\n\ndef check_value(var, value):\n    members = getmembers(sys.modules['moduletotest'])\n    elem = [item for item in members if item[0] == var]\n    assert len(elem) == 1, \"'%s' n'existe pas\" % (var)\n    assert elem[0][1] == value, \"'%s' n'a pas la valeur '%s'\" % (var, value)\n\ndef get_userdefined_variables():\n    return [item for item in dir(sys.modules['moduletotest']) if not item.startswith(\"__\")]\n\ndef get_cleaned_output(out, lines, check = False):\n    output = out.getvalue().strip()\n    l = output.split('\\n')\n    if check == True:\n        assert len(l[-lines:]) == lines, \"Pas assez de lignes affichées !\"\n    return l[-lines:]\n\nclass Test(TestCase):\n    in_0 = ['True', 'False', 'False', 'True', 'False', 'False', 'False', 'False', 'True']\n    @patch('builtins.input', side_effect=in_0)\n    def test_possibilite_0(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 1, True)[0]\n        assert output == \"True\" or output == 'False', \"Aucune valeur correcte n'est renvoyée\"\n\n    in_1 = ['True', 'False', 'False', 'True', 'False', 'False', 'False', 'False', 'True']\n    @patch('builtins.input', side_effect=in_1)\n    def test_possibilite_1(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 1, True)[0]\n        assert output == \"True\", \"état initial: c = False, 3 voisins = cellule centrale vivante\"\n\n    in_2 = ['True', 'False', 'False', 'False', 'True', 'False', 'False', 'False', 'True']\n    @patch('builtins.input', side_effect=in_2)\n    def test_possibilite_2(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 1, True)[0]\n        assert output == \"True\", \"état initial: c = True, 2 voisins = cellule centrale vivante\"\n\n    in_3 = ['False', 'True', 'False', 'False', 'True', 'False', 'False', 'False', 'True']\n    @patch('builtins.input', side_effect=in_3)\n    def test_possibilite_3(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 1, True)[0]\n        assert output == \"True\", \"état initial: c = True, 2 voisins = cellule centrale vivante\"\n\n    in_4 = ['False', 'False', 'True', 'True', 'True', 'False', 'False', 'False', 'True']\n    @patch('builtins.input', side_effect=in_4)\n    def test_possibilite_4(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 1, True)[0]\n        assert output == \"True\", \"état initial: c = True, 3 voisins = cellule centrale vivante\"\n\n    in_5 = ['False', 'False', 'True', 'False', 'True', 'False', 'False', 'False', 'True']\n    @patch('builtins.input', side_effect=in_5)\n    def test_possibilite_5(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 1, True)[0]\n        assert output == \"True\", \"état initial: c = True, 2 voisins = cellule centrale vivante\"\n\n    in_6 = ['False', 'False', 'False', 'False', 'False', 'False', 'False', 'False', 'True']\n    @patch('builtins.input', side_effect=in_6)\n    def test_possibilite_6(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 1, True)[0]\n        assert output == \"False\", \"état initial: c = False, 1 voisin = cellule centrale morte\"\n\n    in_7 = ['False', 'False', 'False', 'False', 'False', 'False', 'False', 'False', 'False']\n    @patch('builtins.input', side_effect=in_7)\n    def test_possibilite_7(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 1, True)[0]\n        assert output == \"False\", \"aucun voisin = cellule centrale morte\"\n\n    in_8 = ['False', 'True', 'False', 'True', 'True', 'True', 'False', 'True', 'True']\n    @patch('builtins.input', side_effect=in_8)\n    def test_possibilite_8(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 1, True)[0]\n        assert output == \"False\", \"état initial: c = True, 4 voisins = cellule centrale morte\"\n\n    in_9 = ['True', 'True', 'True', 'True', 'False', 'True', 'True', 'True', 'True']\n    @patch('builtins.input', side_effect=in_9)\n    def test_possibilite_9(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 1, True)[0]\n        assert output == \"False\", \"état initial: c = False, 8 voisins = cellule centrale morte\"\n\n    in_10 = ['False', 'True', 'False', 'True', 'False', 'True', 'False', 'True', 'False']\n    @patch('builtins.input', side_effect=in_10)\n    def test_possibilite_10(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 1, True)[0]\n        assert output == \"False\", \"état initial: c = False, 4 voisins = cellule centrale morte\"\n\n    in_11 = ['True', 'False', 'True', 'False', 'True', 'False', 'True', 'False', 'True']\n    @patch('builtins.input', side_effect=in_11)\n    def test_possibilite_11(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 1, True)[0]\n        assert output == \"False\", \"état initial: c = True, 4 voisins = cellule centrale morte\"\n\n    in_12 = ['True', 'False', 'True', 'False', 'False', 'False', 'True', 'False', 'False']\n    @patch('builtins.input', side_effect=in_12)\n    def test_possibilite_12(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 1, True)[0]\n        assert output == \"True\", \"état initial: c = False, 3 voisins = cellule centrale morte\"\n",
        "solution": "print(\"nw ?\")\nnw = 1 if input() == \"True\" else 0\nprint(\"nn ?\")\nnn = 1 if input() == \"True\" else 0\nprint(\"ne ?\")\nne = 1 if input() == \"True\" else 0\n\nprint(\"ww ?\")\nww = 1 if input() == \"True\" else 0\nprint(\"c ?\")\nc = 1 if input() == \"True\" else 0\nprint(\"ee ?\")\nee = 1 if input() == \"True\" else 0\n\nprint(\"sw ?\")\nsw = 1 if input() == \"True\" else 0\nprint(\"ss ?\")\nss = 1 if input() == \"True\" else 0\nprint(\"se ?\")\nse = 1 if input() == \"True\" else 0\n\ntotal = nw + nn + ne + ww + ee + sw + ss + se\n\nif (c == 1 and total == 2) or total == 3:\n    print(\"True\")\nelse:\n    print(\"False\")\n",
        "template_regions": [
          ""
        ],
        "template_regions_rw": [
          0
        ],
        "difficulty": 0,
        "score": 0,
        "creation_date": "2020-02-28T12:32:53.139Z"
      },
      {
        "sequence_id": 6,
        "title": "Équations du second degré",
        "lang": "python",
        "instructions": "Concevoir un algorithme qui saisit des coefficients réels a, b et c d'un polynôme\nP[X] = aX^2 + bX + c puis qui affiche les racines réelles ou complexes de l'équation\nP[X] = 0.\n\nLes racines doivent être affichées systématiquement avec deux décimales.\nLe format attendu pour les nombres complexes est (X.YZ, A.BCi)\n\nLes plus motivés pourront répéter l'exercice avec les équations de degré 3.\n\nExemples:\n```\na ? 3\nb ? 5\nc ? 7\n(-0.83, 1.28i)\n(-0.83, -1.28i)\n```\n\n```\na ? 4\nb ? 4\nc ? 1\n-0.50\n```\n",
        "tests": "from unittest.mock import patch\nfrom unittest import TestCase\nfrom inspect import getmembers\n\nimport sys\nimport imp\nfrom contextlib import contextmanager\nfrom io import StringIO\n\n@contextmanager\ndef captured_output():\n    new_out = StringIO()\n    old_out = sys.stdout\n    try:\n        sys.stdout = new_out\n        yield sys.stdout\n    finally:\n        sys.stdout = old_out\n\ndef load_module():\n    if 'moduletotest' in sys.modules:\n        imp.reload(sys.modules['moduletotest'])\n    else:\n        import moduletotest\n\ndef check_value(var, value):\n    members = getmembers(sys.modules['moduletotest'])\n    elem = [item for item in members if item[0] == var]\n    assert len(elem) == 1, \"'%s' n'existe pas\" % (var)\n    assert elem[0][1] == value, \"'%s' n'a pas la valeur '%s'\" % (var, value)\n\ndef get_userdefined_variables():\n    return [item for item in dir(sys.modules['moduletotest']) if not item.startswith(\"__\")]\n\ndef get_cleaned_output(out, lines, check = False):\n    output = out.getvalue().strip()\n    l = output.split('\\n')\n    if check == True:\n        assert len(l[-lines:]) == lines, \"Pas assez de lignes affichées !\"\n    return l[-lines:]\n\nclass Test(TestCase):\n    in_0 = ['3', '5', '7']\n    @patch('builtins.input', side_effect=in_0)\n    def test_delta_inf_0(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 2, True)\n        assert output[0] == '(-0.83, 1.28i)'\n        assert output[1] == '(-0.83, -1.28i)'\n\n    in_1 = ['4', '4', '1']\n    @patch('builtins.input', side_effect=in_1)\n    def test_delta_eq_0(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 1)\n        assert output[0] == '-0.50'\n\n    in_2 = ['2', '9', '-5']\n    @patch('builtins.input', side_effect=in_2)\n    def test_delta_sup_0(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 2, True)\n        assert output[0] == '-5.00'\n        assert output[1] == '0.50'\n\n    in_3 = ['-1', '2', '3']\n    @patch('builtins.input', side_effect=in_3)\n    def test_delta_sup_1(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 2, True)\n        assert output[0] == '3.00'\n        assert output[1] == '-1.00'\n\n    in_4 = ['1', '-6', '-1']\n    @patch('builtins.input', side_effect=in_4)\n    def test_delta_sup_2(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 2, True)\n        assert output[0] == '-0.16'\n        assert output[1] == '6.16'\n",
        "solution": "from math import sqrt\nprint(\"a ?\")\na = int(input())\nprint(\"b ?\")\nb = int(input())\nprint(\"c ?\")\nc = int(input())\n\ndelta = b * b - 4 * a * c\n\nif delta > 0:\n    x1 = (-b - sqrt(delta)) / (2 * a)\n    x2 = (-b + sqrt(delta)) / (2 * a)\n    print(\"{0:.2f}\".format(x1))\n    print(\"{0:.2f}\".format(x2))\nelif delta == 0:\n    x0 = -b / (2 * a)\n    print(\"{0:.2f}\".format(x0))\nelse:\n    x1 = (-b + complex(0, sqrt(-delta))) / (2 * a)\n    x2 = (-b - complex(0, sqrt(-delta))) / (2 * a)\n    print(\"({0:.2f}, {1:.2f}i)\".format(x1.real, x1.imag))\n    print(\"({0:.2f}, {1:.2f}i)\".format(x2.real, x2.imag))\n",
        "template_regions": [
          ""
        ],
        "template_regions_rw": [
          0
        ],
        "difficulty": 0,
        "score": 0,
        "creation_date": "2020-02-28T12:32:53.139Z"
      }
    ]
  },
  {
    "name": "TP3",
    "exercises": [
      {
        "sequence_id": 0,
        "title": "Menu principal d'un programme",
        "lang": "python",
        "instructions": "Concevoir un algorithme qui :\n1. affiche un menu comportant les choix a, b, c proposés à l’utilisateur\n2. suivant le choix de l’utilisateur :\n  1. affiche \"Hello World !\" et repart en 1  \n  2. affiche \"How are you ?\" et repart en 1  \n  3. termine le programme  \n  4. choix incorrect : affiche un message d’erreur et repart en 1\n\nLe menu à afficher est le suivant :\n```\na) Execute HelloWorld\nb) Execute HowAreYou\nc) Quit\n```\n",
        "tests": "from unittest.mock import patch\nfrom unittest import TestCase\nfrom inspect import getmembers\n\nimport sys\nimport imp\nfrom contextlib import contextmanager\nfrom io import StringIO\nimport pytest\n\n@contextmanager\ndef captured_output():\n    new_out = StringIO()\n    old_out = sys.stdout\n    try:\n        sys.stdout = new_out\n        yield sys.stdout\n    finally:\n        sys.stdout = old_out\n\ndef load_module():\n    if 'moduletotest' in sys.modules:\n        imp.reload(sys.modules['moduletotest'])\n    else:\n        import moduletotest\n\ndef check_value(var, value):\n    members = getmembers(sys.modules['moduletotest'])\n    elem = [item for item in members if item[0] == var]\n    assert len(elem) == 1, \"'%s' n'existe pas\" % (var)\n    assert elem[0][1] == value, \"'%s' n'a pas la valeur '%s'\" % (var, value)\n\ndef get_userdefined_variables():\n    return [item for item in dir(sys.modules['moduletotest']) if not item.startswith(\"__\")]\n\ndef get_cleaned_output(out, lines = -1):\n    output = out.getvalue().strip()\n    l = output.split('\\n')\n    if lines == -1:\n        return l\n    else:\n        return l[-lines:]\n\nclass Test(TestCase):\n    in_0 = ['a', 'c']\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=in_0)\n    def test_hello_world(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 7)\n        assert output[0] == 'a) Execute HelloWorld'\n        assert output[1] == 'b) Execute HowAreYou'\n        assert output[2] == 'c) Quit'\n        assert output[3] == 'Hello World !'\n\n    in_1 = ['c']\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=in_1)\n    def test_stop(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 3)\n        assert output[0] == 'a) Execute HelloWorld'\n        assert output[1] == 'b) Execute HowAreYou'\n        assert output[2] == 'c) Quit'\n\n    in_2 = ['a', 'a', 'c']\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=in_2)\n    def test_deux_fois_1(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 11)\n        assert output[0] == 'a) Execute HelloWorld'\n        assert output[1] == 'b) Execute HowAreYou'\n        assert output[2] == 'c) Quit'\n        assert output[3] == 'Hello World !'\n        assert output[4] == 'a) Execute HelloWorld'\n        assert output[5] == 'b) Execute HowAreYou'\n        assert output[6] == 'c) Quit'\n        assert output[7] == 'Hello World !'\n        assert output[8] == 'a) Execute HelloWorld'\n        assert output[9] == 'b) Execute HowAreYou'\n        assert output[10] == 'c) Quit'\n\n    in_3 = ['b', 'a', 'c']\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=in_3)\n    def test_deux_fois_2(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 11)\n        assert output[0] == 'a) Execute HelloWorld'\n        assert output[1] == 'b) Execute HowAreYou'\n        assert output[2] == 'c) Quit'\n        assert output[3] == 'How are you ?'\n        assert output[4] == 'a) Execute HelloWorld'\n        assert output[5] == 'b) Execute HowAreYou'\n        assert output[6] == 'c) Quit'\n        assert output[7] == 'Hello World !'\n        assert output[8] == 'a) Execute HelloWorld'\n        assert output[9] == 'b) Execute HowAreYou'\n        assert output[10] == 'c) Quit'\n\n    in_4 = ['test', 'a', 'c']\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=in_4)\n    def test_mauvais_choix(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 11)\n        assert output[0] == 'a) Execute HelloWorld'\n        assert output[1] == 'b) Execute HowAreYou'\n        assert output[2] == 'c) Quit'\n        assert output[3] != 'Hello World !'\n        assert output[3] != 'How are you ?'\n        assert output[4] == 'a) Execute HelloWorld'\n        assert output[5] == 'b) Execute HowAreYou'\n        assert output[6] == 'c) Quit'\n        assert output[7] == 'Hello World !'\n        assert output[8] == 'a) Execute HelloWorld'\n        assert output[9] == 'b) Execute HowAreYou'\n        assert output[10] == 'c) Quit'\n",
        "solution": "from math import sqrt\n\nchoice = ''\n\nprint(\"Choisissez votre action:\")\n\nwhile choice != 'c':\n    print(\"a) Execute HelloWorld\")\n    print(\"b) Execute HowAreYou\")\n    print(\"c) Quit\")\n    choice = input()\n\n    if choice == 'a':\n        print(\"Hello World !\")\n    elif choice == 'b':\n        print(\"How are you ?\")\n    elif choice == 'c':\n        break\n    else:\n        print(\"Mauvais choix !\")\n",
        "template_regions": [
          ""
        ],
        "template_regions_rw": [
          0
        ],
        "difficulty": 0,
        "score": 0,
        "creation_date": "2020-02-28T12:32:53.139Z"
      },
      {
        "sequence_id": 1,
        "title": "Nombre secret",
        "lang": "python",
        "instructions": "Écrire un programme qui demande à l'utilisateur de trouver un nombre entier secret compris entre 0 et 1000.\n\nPour cela, il est guidé par le programme qui lui indique à chaque essai \"Le nombre secret est plus grand.\" ou\n\"Le nombre secret est plus petit.\". L'utilisateur doit trouver le nombre secret en au plus dix essais.\n\nLorsque le jeu se termine, le programme affiche le résultat `Gagné en {n} essais !` ou `Perdu !`.\n\n",
        "tests": "from unittest.mock import patch\nfrom unittest import TestCase\nfrom inspect import getmembers\n\nimport sys\nimport imp\nfrom contextlib import contextmanager\nfrom io import StringIO\nimport pytest\nfrom math import ceil\n\n@contextmanager\ndef captured_output():\n    new_out = StringIO()\n    old_out = sys.stdout\n    try:\n        sys.stdout = new_out\n        yield sys.stdout\n    finally:\n        sys.stdout = old_out\n\ndef load_module():\n    if 'moduletotest' in sys.modules:\n        imp.reload(sys.modules['moduletotest'])\n    else:\n        import moduletotest\n\ndef check_value(var, value):\n    members = getmembers(sys.modules['moduletotest'])\n    elem = [item for item in members if item[0] == var]\n    assert len(elem) == 1, \"'%s' n'existe pas\" % (var)\n    assert elem[0][1] == value, \"'%s' n'a pas la valeur '%s'\" % (var, value)\n\ndef get_userdefined_variables():\n    return [item for item in dir(sys.modules['moduletotest']) if not item.startswith(\"__\")]\n\ndef get_cleaned_output(out, lines = -1):\n    output = out.getvalue().strip()\n    l = output.split('\\n')\n    if lines == -1:\n        return l\n    else:\n        return l[-lines:]\n\nprev_dir = ''\nnew_dir = ''\nprev_val = 0\nvaleur = 500\ni = [500, 500]\noutput = ''\nnbtests = 0\n\ntest_output = []\ninit = True\n\ndef is_in_interval (interval, val):\n    if val > interval[0] and val > interval[1]:\n        return False\n    elif val >= interval[0] or val >= interval[1]:\n        return True\n    else:\n        return False\n\ndef between (interval):\n    return ceil((interval[0] + interval[1]) / 2)\n\n\ndef set_values (interval, val, curr, new_dir, prev_dir):\n    curr_index = 0 if curr == interval[0] else 1\n    tmp = interval[curr_index]\n\n    interval[curr_index] = val\n\n    if new_dir == prev_dir or prev_dir == '':\n        interval[0 if curr_index else 1] = tmp\n\ndef guess_number (data = \"\"):\n    global prev_dir, new_dir, prev_val, valeur, i, output, init, nbtests\n\n    nbtests = nbtests + 1\n\n    if init == True:\n        init = False\n        return 500\n\n    prev_dir = new_dir\n    if data:\n        new_dir = get_cleaned_output(output, 1)[0]\n    else:\n        new_dir = get_cleaned_output(output, 2)[0]\n\n    if 'Gagné' in new_dir:\n        raise Exception(\"Lorsque le joueur a gagné, il ne devrait avoir à saisir à nouveau une valeur !\")\n\n    if new_dir == 'Perdu !':\n        raise Exception(\"Lorsque le joueur a perdu, il ne devrait avoir à saisir à nouveau une valeur !\")\n\n    if prev_dir != new_dir and prev_dir:\n        min_val = min(i[0], i[1])\n        max_val = max(i[0], i[1])\n\n        if new_dir == 'Le nombre secret est plus grand.':\n            if prev_val < max_val:\n                set_values(i, prev_val, max_val, new_dir, prev_dir)\n            set_values(i, valeur, min_val, new_dir, prev_dir)\n        elif new_dir == 'Le nombre secret est plus petit.':\n            if prev_val > min_val:\n                set_values(i, prev_val, min_val, new_dir, prev_dir)\n            set_values(i, valeur, max_val, new_dir, prev_dir)\n        else:\n            raise Exception(\"Le message n'est ni 'Le nombre secret est plus grand.', ni 'Le nombre secret est plus petit.'\")\n\n    prev_val = valeur\n\n    min_val = min(i[0], i[1], valeur)\n    max_val = max(i[0], i[1], valeur)\n\n    between_interval = [min_val, max_val]\n\n    if new_dir == 'Le nombre secret est plus grand.':\n        if is_in_interval(i, valeur + 1) == False:\n            between_interval = [1000, max_val]\n        elif valeur > min_val:\n            between_interval = [valeur, max_val]\n    else:\n        if is_in_interval(i, valeur - 1) == False:\n            between_interval = [0, min_val]\n        elif valeur < max_val:\n            between_interval = [min_val, valeur]\n\n    valeur = between(between_interval)\n    return valeur\n\n\nclass Test(TestCase):\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=guess_number)\n    def test_1(self, input):\n        global output, nbtests, valeur\n        with captured_output() as out:\n            output = out\n            load_module()\n        out2 = get_cleaned_output(out)\n        assert nbtests > 0, \"Le jeu n'a même pas demandé d'informations à l'utilisateur\"\n        assert 'Gagné' in out2[-1], \"Le jeu ne fonctionne pas correctement\"\n\n        members = getmembers(sys.modules['moduletotest'])\n        elem = [item for item in members if item[1] == valeur or item[1] == str(valeur)]\n        nbvariables = len(elem)\n        assert nbvariables >= 2, \"Le jeu a été gagné sans trouver le nombre secret, car deux variables devraient contenir la valeur %d (le nombre secret, et la valeur envoyée par l'utilisateur), ce qui n'est pas le cas ici.\" % (valeur)\n",
        "solution": "from random import randint\n\nval = randint(0, 1000)\n\nuserval = 0\nessais = 0\n\nwhile userval != val and essais <= 10:\n    essais += 1\n    if essais > 10:\n        print(\"Perdu !\")\n    else:\n        print(\"Entrez une valeur (%d):\" % (val))\n        userval = int(input())\n        if userval > val:\n            print(\"Le nombre secret est plus petit.\")\n        elif userval < val:\n            print(\"Le nombre secret est plus grand.\")\n        else:\n            print(\"Gagné en %d essais !\" % (essais))\n",
        "template_regions": [
          ""
        ],
        "template_regions_rw": [
          0
        ],
        "difficulty": 0,
        "score": 0,
        "creation_date": "2020-02-28T12:32:53.140Z"
      },
      {
        "sequence_id": 2,
        "title": "PGCD",
        "lang": "python",
        "instructions": "Écrire un programme qui demande à l'utilisateur deux entiers a et b non nuls et qui calcule et affiche le plus\ngrand diviseur commun de a et b en utilisant la méthode d'Euclide.\nLa sortie du programme doit correspondre à \"Le PGCD est {nb}\" où {nb} doit être remplacé par le pgcd calculé.\n",
        "tests": "from unittest.mock import patch\nfrom unittest import TestCase\nfrom inspect import getmembers\n\nimport sys\nimport imp\nfrom contextlib import contextmanager\nfrom io import StringIO\nimport pytest\n\n@contextmanager\ndef captured_output():\n    new_out = StringIO()\n    old_out = sys.stdout\n    try:\n        sys.stdout = new_out\n        yield sys.stdout\n    finally:\n        sys.stdout = old_out\n\ndef load_module():\n    if 'moduletotest' in sys.modules:\n        imp.reload(sys.modules['moduletotest'])\n    else:\n        import moduletotest\n\ndef check_value(var, value):\n    members = getmembers(sys.modules['moduletotest'])\n    elem = [item for item in members if item[0] == var]\n    assert len(elem) == 1, \"'%s' n'existe pas\" % (var)\n    assert elem[0][1] == value, \"'%s' n'a pas la valeur '%s'\" % (var, value)\n\ndef get_userdefined_variables():\n    return [item for item in dir(sys.modules['moduletotest']) if not item.startswith(\"__\")]\n\ndef get_cleaned_output(out, lines, check = False):\n    output = out.getvalue().strip()\n    l = output.split('\\n')\n    if check == True:\n        assert len(l[-lines:]) == lines, \"Pas assez de lignes affichées !\"\n    return l[-lines:]\n\nclass Test(TestCase):\n    in_0 = ['10', '20']\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=in_0)\n    def test_pgcd_10_20(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 1, True)[0]\n        assert output == \"Le PGCD est 10\"\n\n    in_1 = ['1920', '3448']\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=in_1)\n    def test_pgcd_1920_3448(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 1, True)[0]\n        assert output == \"Le PGCD est 8\"\n\n    in_2 = ['238293829', '473847383']\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=in_2)\n    def test_pgcd_238293829_473847383(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 1, True)[0]\n        assert output == \"Le PGCD est 1\"\n\n    in_3 = ['987656374', '987656374']\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=in_3)\n    def test_987656374_987656374(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 1, True)[0]\n        assert output == \"Le PGCD est 987656374\"\n",
        "solution": "print(\"a ?\")\na = int(input())\nprint(\"b ?\")\nb = int(input())\n\nwhile b != 0:\n    r = a % b\n    a, b = b, r\n\nprint(\"Le PGCD est %d\" % (a))\n",
        "template_regions": [
          ""
        ],
        "template_regions_rw": [
          0
        ],
        "difficulty": 0,
        "score": 0,
        "creation_date": "2020-02-28T12:32:53.140Z"
      },
      {
        "sequence_id": 3,
        "title": "PPCM",
        "lang": "python",
        "instructions": "Écrire un programme qui demande à l'utilisateur deux entiers a et b non nuls et qui calcule et affiche le plus\npetit multiple commun de a et b.\nLa sortie du programme doit correspondre à \"Le PPCM est {nb}\" où {nb} doit être remplacé par le ppcm calculé.\n",
        "tests": "from unittest.mock import patch\nfrom unittest import TestCase\nfrom inspect import getmembers\n\nimport sys\nimport imp\nfrom contextlib import contextmanager\nfrom io import StringIO\nimport pytest\n\n@contextmanager\ndef captured_output():\n    new_out = StringIO()\n    old_out = sys.stdout\n    try:\n        sys.stdout = new_out\n        yield sys.stdout\n    finally:\n        sys.stdout = old_out\n\ndef load_module():\n    if 'moduletotest' in sys.modules:\n        imp.reload(sys.modules['moduletotest'])\n    else:\n        import moduletotest\n\ndef check_value(var, value):\n    members = getmembers(sys.modules['moduletotest'])\n    elem = [item for item in members if item[0] == var]\n    assert len(elem) == 1, \"'%s' n'existe pas\" % (var)\n    assert elem[0][1] == value, \"'%s' n'a pas la valeur '%s'\" % (var, value)\n\ndef get_userdefined_variables():\n    return [item for item in dir(sys.modules['moduletotest']) if not item.startswith(\"__\")]\n\ndef get_cleaned_output(out, lines, check = False):\n    output = out.getvalue().strip()\n    l = output.split('\\n')\n    if check == True:\n        assert len(l[-lines:]) == lines, \"Pas assez de lignes affichées !\"\n    return l[-lines:]\n\nclass Test(TestCase):\n    in_0 = ['10', '20']\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=in_0)\n    def test_ppcm_10_20(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 1, True)[0]\n        assert output == \"Le PPCM est 20\"\n\n    in_1 = ['1920', '3448']\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=in_1)\n    def test_ppcm_1920_3448(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 1, True)[0]\n        assert output == \"Le PPCM est 827520\"\n\n    in_2 = ['238293829', '473847383']\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=in_2)\n    def test_ppcm_238293829_473847383(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 1, True)[0]\n        assert output == \"Le PPCM est 112914907256699507\" or output == \"Le PPCM est 112914907256699504\"\n\n    in_3 = ['987656374', '987656374']\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=in_3)\n    def test_ppcm_987656374_987656374(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 1, True)[0]\n        assert output == \"Le PPCM est 987656374\"\n\n    in_4 = ['0', '0']\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=in_4)\n    def test_ppcm_0_0(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 1, True)[0]\n        assert output == \"Le PPCM est 0\"\n",
        "solution": "print(\"a ?\")\na = int(input())\nprint(\"b ?\")\nb = int(input())\n\nif a == 0 or b == 0:\n    print(\"Le PPCM est 0\")\nelse:\n    retained_a, retained_b = a, b\n    while b != 0:\n        r = a % b\n        a, b = b, r\n    # the '//' sign is an integer division\n    ppcm = (retained_a * retained_b) // a\n\n    print(\"Le PPCM est %d\" % (ppcm))\n",
        "template_regions": [
          ""
        ],
        "template_regions_rw": [
          0
        ],
        "difficulty": 0,
        "score": 0,
        "creation_date": "2020-02-28T12:32:53.140Z"
      },
      {
        "sequence_id": 4,
        "title": "Somme",
        "lang": "python",
        "instructions": "On définit la somme: \nSm(n) par: Sm(n) = 1^m + 2^m + ... + n^m pour n,m > 0. \nÉcrire un programme qui effectue une saisie contrôlée de deux entiers strictement positifs, calcule et affiche\nle résultat.\n\n",
        "tests": "from unittest.mock import patch\nfrom unittest import TestCase\nfrom inspect import getmembers\n\nimport sys\nimport imp\nfrom contextlib import contextmanager\nfrom io import StringIO\nimport pytest\n\n@contextmanager\ndef captured_output():\n    new_out = StringIO()\n    old_out = sys.stdout\n    try:\n        sys.stdout = new_out\n        yield sys.stdout\n    finally:\n        sys.stdout = old_out\n\ndef load_module():\n    if 'moduletotest' in sys.modules:\n        imp.reload(sys.modules['moduletotest'])\n    else:\n        import moduletotest\n\ndef check_value(var, value):\n    members = getmembers(sys.modules['moduletotest'])\n    elem = [item for item in members if item[0] == var]\n    assert len(elem) == 1, \"'%s' n'existe pas\" % (var)\n    assert elem[0][1] == value, \"'%s' n'a pas la valeur '%s'\" % (var, value)\n\ndef get_userdefined_variables():\n    return [item for item in dir(sys.modules['moduletotest']) if not item.startswith(\"__\")]\n\ndef get_cleaned_output(out, lines, check = False):\n    output = out.getvalue().strip()\n    l = output.split('\\n')\n    if check == True:\n        assert len(l[-lines:]) == lines, \"Pas assez de lignes affichées !\"\n    return l[-lines:]\n\nclass Test(TestCase):\n    in_0 = ['1', '1']\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=in_0)\n    def test_n1_m1(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 1, True)[0]\n        assert output == \"1\"\n\n    in_1 = ['2', '1']\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=in_1)\n    def test_n2_m1(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 1, True)[0]\n        assert output == \"3\"\n\n    in_2 = ['2', '2']\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=in_2)\n    def test_n2_m2(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 1, True)[0]\n        assert output == \"5\"\n\n    in_3 = ['10', '2']\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=in_3)\n    def test_n10_m_2(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 1, True)[0]\n        assert output == \"385\"\n\n    in_4 = ['10', '5998']\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=in_4)\n    def test_n10_m100(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 1, True)[0]\n        assert output==\"10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000352023467957135208382759088179507565171093055703518989749222819529587484417804522197328993914245640608176739427447222771538180083482870656442900030281923712516304749499124971688051831611876539261411492516569260184943597344175166257716350292783508136402199466900699121252094219922034302977784626000914186554958725625244433405980773021967376909101212897819064416197490922124155794680491736273093125782926742047980568747286383150789730796090381773407929496813070369704622227671482914395050430052088315816036749072424952341336117537695478609682832000381789813686188905023510229117784068588706659863234779263332898931490792248485395308167597778635205157919873163578468835636574671569824533268776249650254452404160841811543653516966353195713585644711193866243551787915856430328118720847107782838922078949518679485963529352153396140107417013660669997183840372766584837048821515681093790559089752136179859253882463390255943156371717301275816561950300791524171182935476289798213499382029421142844640952983198169156127372520258310427106693896978560626940829211044382071025768952985917848587557385830112724853993531927922884319390531953929157106535699591878871125503168941745893221220667683684174135951072786397176409621748096040281891867219186261343657722413665299658078948610074189179627280129107648132087347621246573879992081803175747554563414512546384511275448867416555008191748796059281442423482079945869383293982454514429483503529231631154337001887679117536138210394025207532159334211494790906204199463120038636787459600080540298350068953681060146425610839611127917640514598293701893615094399556708067324121824685539847921794477971558690060382902144359500334629319218687601109502097578723536319102791546718680026990327484155997096045834984700921595510922476724892684122307742337963649139743940107103727433597755170804466672433276412157379864966410828102511316406839357751834640335897971845597988800980058076858979920257092947726550248264539729461912541794456535637943297308978558577979002514906357660423973286987020391596794401650983108311951698559043451142858740102835932751995403851511099998465897439309738712931720642078065114105912124084057745216643629237193564186690602065328511348617928049563673705269113997302388104004086209380868449059267467908911568223322862896204485729903954120653312140303301688054319136929658435195139483336136206380510863775947852629704193473157683990833657999757931243316352848514098329799812890125605107932152751663298117843415546326194161921270124527547352879183762688658302371965912243983585089731661496325517008207906912276559655249836150849126505401612301147152897787231452870111902579704251400391674178098064684312489243955508365975130911943788060542632313702076760472921263351893457402067420236294969999023580651648703764248065938508936635960624666353293245597320460725976920450988765423213863302860777249606091837390002934339660136190174653677544406593872650227803420217955145425271885346318570643876788865227385151451288961244031467282515951046928099387414248940803291951359728115534165935944108728626669143518639939672114159874603146647180178088729827799239347580370725101821352003186052815798293930902930192188693919579240173854778593503554698541489912714041233416789586097592026214244235134257495143186941369540793687943884825082928257821252406029256887745426903081721662857884155427266992073908897895790765099600532243789819494353037335849271370568156336502781914547571794778627603336755683482161869630695572886982784953326186183746975800411661636803816332089192122088831779405430934132914236338529545056596754949783697977866980999207341770145339827723940807602275605926828668136649885189156746062516881485330949211262097001163070497644540609595324513336373855745392420700275474052188572224654410731903890203920157835552904500092989721670911558130312838878712164319627209985332273977715055868291352775872385828434609246455094266104200405196285303925546543696742123764239934850793800245534315153420235661743565769724631450703256485403318818282831183907102134100962553395466754438855538870231133944439534706719356602936676325906170947338377657577411898397722466743578845675226333702964458599530483146681539060210527987593505111893164905063967693051185579946137108658203269798232385641804282082234062418135905862364294502344600554837322289892289271215624491266787597491882309458660468275876902558090272223530465895769879505224244243861586602978798109704683418125594183926101780280826811056410186612250398832666192971156617353015971561849065464404104131944859283032701965684223366637287952825634929043773051388537608401941526683319303803854615817175106588218021519667426671530784303496158173986847462699453052792730163843166341834104339690274114408920782410410959175442031956855918577202894321364820550928002792246537146985985652619184547650990098298384362249622606353782374701985676334942650187154911426130051024135388779390321726421147592611492360234315288458167549162289610373919293501856240886014886519833144046850567934490589118724769381874840709038936439485706706339904498342161867665134756892658939989000576098753496748005664355382055233563290007466679446576940530675588439556731299717633016624364070555292628403211449879865511796719342839502327243012846953360749955396709434597371823598931366966802575369337289835171718519946167004719670071406566091155658356293772135799275708302499600429729031149198640547770734905486132833617335038323305894029999646580446263891716202210034510932002153232265450898657013959791704447625531410972718068098947378088742382072596452530854267241063108424481489030002863303768109324524436226201745021807309641478769540239089522240983983727250475924061649317505764874598589079347768491840757589935901021799275143165992767917929080086610307796162679387365\"\n",
        "solution": "print(\"n ?\")\nn = int(input())\nprint(\"m ?\")\nm = int(input())\n\ni = 1\nsomme = 0\nprint('Sm(n) = ', end='')\nwhile i <= n:\n    print('%d^%d' % (i, m), end='')\n    somme = somme + i ** m\n    i += 1\n    if i <= n:\n        print(' + ', end='')\n\nprint('\\n%d' % somme)\n",
        "template_regions": [
          ""
        ],
        "template_regions_rw": [
          0
        ],
        "difficulty": 0,
        "score": 0,
        "creation_date": "2020-02-28T12:32:53.142Z"
      },
      {
        "sequence_id": 5,
        "title": "Nombre premier",
        "lang": "python",
        "instructions": "Écrire un programme qui affiche tous les nombres premiers inférieurs ou égaux à `n`, où `n` est un entier\npositif donné par l'utilisateur. \n`n` est un entier premier s'il n'admet aucun diviseur autre que 1 et `n`.\n\nLes nombres doivent être affichés chacun sur une ligne distincte.\n",
        "tests": "from unittest.mock import patch\nfrom unittest import TestCase\nfrom inspect import getmembers\n\nimport sys\nimport imp\nfrom contextlib import contextmanager\nfrom io import StringIO\nimport pytest\n\n@contextmanager\ndef captured_output():\n    new_out = StringIO()\n    old_out = sys.stdout\n    try:\n        sys.stdout = new_out\n        yield sys.stdout\n    finally:\n        sys.stdout = old_out\n\ndef load_module():\n    if 'moduletotest' in sys.modules:\n        imp.reload(sys.modules['moduletotest'])\n    else:\n        import moduletotest\n\ndef check_value(var, value):\n    members = getmembers(sys.modules['moduletotest'])\n    elem = [item for item in members if item[0] == var]\n    assert len(elem) == 1, \"'%s' n'existe pas\" % (var)\n    assert elem[0][1] == value, \"'%s' n'a pas la valeur '%s'\" % (var, value)\n\ndef get_userdefined_variables():\n    return [item for item in dir(sys.modules['moduletotest']) if not item.startswith(\"__\")]\n\ndef get_cleaned_output(out, lines, check = False):\n    output = out.getvalue().strip()\n    l = output.split('\\n')\n    if check == True:\n        assert len(l[-lines:]) == lines, \"Pas assez de lignes affichées !\"\n    return l[-lines:]\n\nclass Test(TestCase):\n    in_0 = ['1']\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=in_0)\n    def test_1(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 1, True)\n        assert output == ['1']\n\n    in_1 = ['2']\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=in_1)\n    def test_2(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 2, True)\n        assert output == ['1', '2']\n\n    in_2 = ['3']\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=in_2)\n    def test_3(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 3, True)\n        assert output == ['1', '2', '3']\n\n    in_3 = ['4']\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=in_3)\n    def test_4(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 3, True)\n        assert output == ['1', '2', '3']\n\n    in_4 = ['10']\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=in_4)\n    def test_10(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 5, True)\n        assert output == ['1', '2', '3', '5', '7']\n\n    in_5 = ['200']\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=in_5)\n    def test_200(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 46, True)\n        assert output == [\"2\", \"3\", \"5\", \"7\", \"11\", \"13\", \"17\", \"19\", \"23\", \"29\", \"31\", \"37\", \"41\",\n                \"43\", \"47\", \"53\", \"59\", \"61\", \"67\", \"71\", \"73\", \"79\", \"83\", \"89\", \"97\", \"101\", \"103\",\n                \"107\", \"109\", \"113\", \"127\", \"131\", \"137\", \"139\", \"149\", \"151\", \"157\", \"163\", \"167\",\n                \"173\", \"179\", \"181\", \"191\", \"193\", \"197\", \"199\"]\n\n",
        "solution": "print(\"n ?\")\nn = int(input())\n\nprint(1)\n\ni = 1\nwhile i < n:\n    i += 1\n    j = 2\n    while j < i and i % j != 0:\n        j += 1\n\n    if j == i:\n        print(i)\n",
        "template_regions": [
          ""
        ],
        "template_regions_rw": [
          0
        ],
        "difficulty": 0,
        "score": 0,
        "creation_date": "2020-02-28T12:32:53.143Z"
      },
      {
        "sequence_id": 6,
        "title": "Nombre parfait",
        "lang": "python",
        "instructions": "Écrire un programme qui affiche tous les nombres parfaits inférieurs à `n`, qui est un entier positif donné\npar l'utilisateur. \nUn entier positif `n` est parfait s'il est égal à la somme de ses diviseurs (lui-même étant exclus)\n",
        "tests": "from unittest.mock import patch\nfrom unittest import TestCase\nfrom inspect import getmembers\n\nimport sys\nimport imp\nfrom contextlib import contextmanager\nfrom io import StringIO\nimport pytest\n\n@contextmanager\ndef captured_output():\n    new_out = StringIO()\n    old_out = sys.stdout\n    try:\n        sys.stdout = new_out\n        yield sys.stdout\n    finally:\n        sys.stdout = old_out\n\ndef load_module():\n    if 'moduletotest' in sys.modules:\n        imp.reload(sys.modules['moduletotest'])\n    else:\n        import moduletotest\n\ndef check_value(var, value):\n    members = getmembers(sys.modules['moduletotest'])\n    elem = [item for item in members if item[0] == var]\n    assert len(elem) == 1, \"'%s' n'existe pas\" % (var)\n    assert elem[0][1] == value, \"'%s' n'a pas la valeur '%s'\" % (var, value)\n\ndef get_userdefined_variables():\n    return [item for item in dir(sys.modules['moduletotest']) if not item.startswith(\"__\")]\n\ndef get_cleaned_output(out, lines, check = False):\n    output = out.getvalue().strip()\n    l = output.split('\\n')\n    if check == True:\n        assert len(l[-lines:]) == lines, \"Pas assez de lignes affichées !\"\n    return l[-lines:]\n\nclass Test(TestCase):\n    in_0 = ['10']\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=in_0)\n    def test_10(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 1, True)\n        assert output == ['6']\n\n    in_1 = ['100']\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=in_1)\n    def test_100(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 2, True)\n        assert output == ['6', '28']\n\n    in_2 = ['1000']\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=in_2)\n    def test_1000(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 3, True)\n        assert output == ['6', '28', '496']\n\n    #in_3 = ['9000']\n\n    #@pytest.mark.timeout(5)\n    #@patch('builtins.input', side_effect=in_3)\n    #def test_9000(self, input):\n    #    with captured_output() as out:\n    #        load_module()\n    #    output = get_cleaned_output(out, 4, True)\n    #    assert output == ['6', '28', '496', '8128']\n\n    #in_4 = ['33550337']\n\n    #@pytest.mark.timeout(3)\n    #@patch('builtins.input', side_effect=in_4)\n    #def test_challenge_33550337(self, input):\n    #    with captured_output() as out:\n    #        load_module()\n    #    output = get_cleaned_output(out, 4, True)\n    #    assert output == ['6', '28', '496', '8128', '33550336']\n",
        "solution": "print(\"n ?\")\nn = int(input())\n\n## ici la boucle est très longue parce qu'on se tape toute la liste à chaque itération\n## on peut très probablement améliorer les perfs de l'algo\n## en effet, il y a une simplification\ndef v1 ():\n    global n\n    i = 1\n    maxcalc = 0\n    while i < n:\n        j = 1\n        somme = 0\n        while j < i:\n            if i % j == 0:\n                somme += j\n            j += 1\n            if i < somme:\n                break\n        if j == somme:\n            print(j)\n        i += 1\nv1()\n\n# 2^p−1× (2^p − 1)) whenever 2^p − 1 is a Mersenne prime\ndef v2 ():\n    return False\n",
        "template_regions": [
          ""
        ],
        "template_regions_rw": [
          0
        ],
        "difficulty": 0,
        "score": 0,
        "creation_date": "2020-02-28T12:32:53.143Z"
      },
      {
        "sequence_id": 7,
        "title": "Affichage d'un triangle",
        "lang": "python",
        "instructions": "a) Écrire un programme qui demande à l'utilisateur la hauteur H d'un triangle, puis affiche le triangle rectangle\nisocèle d'étoiles correspondant. \nExemple, pour H = 3, on aura l'affichage suivant:\n```\n* \n** \n***\n```\n\nb) Écrire une deuxième version du programme qui affiche le triangle à l'envers. \nExemple, pour H = 3, on aura l'affichage suivant: \n```\n***\n**\n*\n```\n\n**NOTE**: Votre programme final doit afficher successivement le triangle à l'endroit puis à l'envers, comme\nceci (si H = 3):\n```\n*\n**\n***\n***\n**\n*\n```\n",
        "tests": "from unittest.mock import patch\nfrom unittest import TestCase\nfrom inspect import getmembers\n\nimport sys\nimport imp\nfrom contextlib import contextmanager\nfrom io import StringIO\nimport pytest\n\n@contextmanager\ndef captured_output():\n    new_out = StringIO()\n    old_out = sys.stdout\n    try:\n        sys.stdout = new_out\n        yield sys.stdout\n    finally:\n        sys.stdout = old_out\n\ndef load_module():\n    if 'moduletotest' in sys.modules:\n        imp.reload(sys.modules['moduletotest'])\n    else:\n        import moduletotest\n\ndef check_value(var, value):\n    members = getmembers(sys.modules['moduletotest'])\n    elem = [item for item in members if item[0] == var]\n    assert len(elem) == 1, \"'%s' n'existe pas\" % (var)\n    assert elem[0][1] == value, \"'%s' n'a pas la valeur '%s'\" % (var, value)\n\ndef get_userdefined_variables():\n    return [item for item in dir(sys.modules['moduletotest']) if not item.startswith(\"__\")]\n\ndef get_cleaned_output(out, lines, check = False):\n    output = out.getvalue().strip()\n    l = output.split('\\n')\n    if check == True:\n        assert len(l[-lines:]) == lines, \"Pas assez de lignes affichées !\"\n    return l[-lines:]\n\nclass Test(TestCase):\n    in_0 = ['1']\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=in_0)\n    def test_10(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 2, True)\n        assert output == ['*', '*']\n\n    in_1 = ['2']\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=in_1)\n    def test_100(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 4, True)\n        assert output == ['*', '**', '**', '*']\n\n    in_2 = ['3']\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=in_2)\n    def test_1000(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 6, True)\n        assert output == ['*', '**', '***', '***', '**', '*']\n",
        "solution": "print(\"h ?\")\nh = int(input())\n\ni = 1\n\nwhile i <= h:\n    print ('*' * i)\n    i += 1\n\ni -= 1\nwhile i > 0:\n    print ('*' * i)\n    i -= 1\n",
        "template_regions": [
          ""
        ],
        "template_regions_rw": [
          0
        ],
        "difficulty": 0,
        "score": 0,
        "creation_date": "2020-02-28T12:32:53.144Z"
      },
      {
        "sequence_id": 8,
        "title": "Affichage d'une suite de triangles",
        "lang": "python",
        "instructions": "Écrire un programme qui demande à l'utilisateur deux entiers N et H, puis affiche N triangles isocèles\nd'étoiles chacun dans une ligne. Chaque triangle est de hauteur H.\nExemple, pour N = 4 et H = 3, on aura l'affichage suivant:\n```\n* \n** \n***\n* \n** \n***\n* \n** \n***\n* \n** \n***\n* \n** \n***\n```\n",
        "tests": "from unittest.mock import patch\nfrom unittest import TestCase\nfrom inspect import getmembers\n\nimport sys\nimport imp\nfrom contextlib import contextmanager\nfrom io import StringIO\nimport pytest\n\n@contextmanager\ndef captured_output():\n    new_out = StringIO()\n    old_out = sys.stdout\n    try:\n        sys.stdout = new_out\n        yield sys.stdout\n    finally:\n        sys.stdout = old_out\n\ndef load_module():\n    if 'moduletotest' in sys.modules:\n        imp.reload(sys.modules['moduletotest'])\n    else:\n        import moduletotest\n\ndef check_value(var, value):\n    members = getmembers(sys.modules['moduletotest'])\n    elem = [item for item in members if item[0] == var]\n    assert len(elem) == 1, \"'%s' n'existe pas\" % (var)\n    assert elem[0][1] == value, \"'%s' n'a pas la valeur '%s'\" % (var, value)\n\ndef get_userdefined_variables():\n    return [item for item in dir(sys.modules['moduletotest']) if not item.startswith(\"__\")]\n\ndef get_cleaned_output(out, lines, check = False):\n    output = out.getvalue().strip()\n    l = output.split('\\n')\n    if check == True:\n        assert len(l[-lines:]) == lines, \"Pas assez de lignes affichées !\"\n    return l[-lines:]\n\ndef get_lines(h, n):\n    o = []\n    j = 0\n    while j < n:\n        i = 1\n        while i <= h:\n            o.append('*' * i)\n            i += 1\n        j += 1\n    return o\n\nclass Test(TestCase):\n    in_0 = ['1', '3']\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=in_0)\n    def test_simple(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 3, True)\n        assert output == ['*', '**', '***']\n\n    in_1 = ['2', '2']\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=in_1)\n    def test_double(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 4, True)\n        assert output == ['*', '**', '*', '**']\n\n    in_2 = ['5', '5']\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=in_2)\n    def test_five(self, input):\n        with captured_output() as out:\n            load_module()\n        output = get_cleaned_output(out, 5 * 5, True)\n        lines = get_lines(5, 5)\n        assert output == lines\n",
        "solution": "print(\"n ?\")\nn = int(input())\nprint(\"h ?\")\nh = int(input())\n\nj = 0\n\nwhile j < n:\n    i = 1\n    while i <= h:\n        print ('*' * i)\n        i += 1\n    j += 1\n",
        "template_regions": [
          ""
        ],
        "template_regions_rw": [
          0
        ],
        "difficulty": 0,
        "score": 0,
        "creation_date": "2020-02-28T12:32:53.148Z"
      },
      {
        "sequence_id": 9,
        "title": "Gestion de compte bancaire",
        "lang": "python",
        "instructions": "On vous présente un système de gestion de compte bancaire: le client dépose un montant initial de `M`€, et,\ntous les deux mois, un montant de versement de `m`€. Tous les 6 mois, en juin et en décembre après le\nversement bimensuel, les intérêts à un taux `T` sont versés sur le compte. Tous les ans, en décembre, si le\nmontant dépasse un seuil `S`, une taxe à un taux `Ttaxe` est prélevée, après versement. Également tous les ans,\ndes frais de gestion de compte d'un montant de 15€ sont prélevés.\n\nÉcrire un programme qui demande de saisir le montant initial `M` et le montant du versement `m`, et\nqui affiche le solde du compte par périodes de deux mois, à la fin du mois. On affiche aussi les\nautres évènements: versement des intérêts, prélèvements. \nOn arrête l'affichage à la fin de la 4e année ou si le solde dépasse un plafond `P`.\n\n**NB**: Les valeurs sont affichées avec une précision au centième. Une façon d'afficher au centieme est d'utiliser les format strings, par exemple:\n```\na = 2.33333\nprint(\"a = %0.2f\" % (a)) # %0.2f sera remplacé par la valeur de a\n```\n\nOn suppose que:\n* Le montant `M` doit être de 10€ minimum, le montant `m` de 100€ minimum;\n* Le taux des intérêts `T` est de 2.25%, le taux `Ttaxe` de 4.25%;\n* Le seuil `S` est de 5 000€, le plafond `P` de 15 000€.\n\nAffichages attendus:\nSi l'utilisateur entre une valeur incorrecte:\n  * `Le montant initial M doit être de 10€ minimum.\\n`\n  * ou `Le versement m doit être de 100€ minimum.\\n`\nPour indiquer informations d'état:\n  * `Solde: {solde}€\\n` où `solde` est affiché avec deux chiffres après la virgule\n  * `Intérêts: +{interets}€\\n` où `interets` est affiché avec deux chiffres après la virgule\n  * `Taxe: -{taxe}€\\n` où `taxe` est affiché avec deux chiffres après la virgule\n  * `Frais: -{frais}€\\n` où `frais` est affiché avec deux chiffres après la virgule\n\n",
        "tests": "",
        "solution": "T = 0.0225\nTtaxe = 0.0425\nMmin = 10\nMmax = 100\nSeuil = 5000\nS = 5000\nP = 15000\nFrais = 15\n\nprint(\"Saisissez le montant initial M\")\nM = int(input())\nprint(\"Saisissez le versement mensuel m\")\nm = int(input())\n\nmois = 1\nsolde = M\n\nif M < 10:\n    print(\"Le montant M doit être de 10€ minimum.\")\nelif m < 100:\n    print(\"Le montant m doit être de 100€ minimum.\")\nelse:\n    while mois <= 4 * 12 and solde < P:\n        if mois % 2 == 1:\n            solde = solde + m\n            print(\"Solde au %d%s mois de la %deme année: %0.2f€\" % (\n                        1 + (mois % 12),\n                        'er' if mois % 12 == 0 else 'eme',\n                        mois / 12,\n                        solde\n                    ))\n        if mois % 6 == 1:\n            print(\"Intérêts: %0.2f€\" % (solde * T))\n            solde = solde + solde * T\n        if mois % 12 == 0 and solde > S:\n            print(\"Taxe: -%0.2f€\" % (solde * Ttaxe))\n            solde = solde - solde * Ttaxe\n        if mois % 12 == 0:\n            print(\"Frais: %0.2d€\" % (Frais))\n            solde = solde - Frais\n\n        mois = mois + 1\n\n\n",
        "template_regions": [
          ""
        ],
        "template_regions_rw": [
          0
        ],
        "difficulty": 0,
        "score": 0,
        "creation_date": "2020-02-28T12:32:53.151Z"
      }
    ]
  },
  {
    "name": "TP4",
    "exercises": [
      {
        "sequence_id": 0,
        "title": "Fonction puissance",
        "lang": "python",
        "instructions": "Concevez une fonction `puissance` qui reçoit en paramètres un nombre entier positif et une\npuissance entière positive, et qui retourne un entier dont la valeur vaut\nnombre<sup>exposant</sup> sans utiliser l'opérateur `**` ni la fonction `pow`.\n",
        "tests": "from unittest.mock import patch\nfrom unittest import TestCase\nfrom inspect import getmembers, signature, getsource\n\nimport sys\nimport imp\nfrom contextlib import contextmanager\nfrom io import StringIO\nimport pytest\n\n@contextmanager\ndef captured_output():\n    new_out = StringIO()\n    old_out = sys.stdout\n    try:\n        sys.stdout = new_out\n        yield sys.stdout\n    finally:\n        sys.stdout = old_out\n\ndef load_module():\n    if 'moduletotest' in sys.modules:\n        imp.reload(sys.modules['moduletotest'])\n    else:\n        import moduletotest\n\ndef check_value(var, value):\n    members = getmembers(sys.modules['moduletotest'])\n    elem = [item for item in members if item[0] == var]\n    assert len(elem) == 1, \"'%s' n'existe pas\" % (var)\n    assert elem[0][1] == value, \"'%s' n'a pas la valeur '%s'\" % (var, value)\n\n\ndef get_function(var):\n    members = getmembers(sys.modules['moduletotest'])\n    elem = [item for item in members if item[0] == var]\n    assert len(elem) == 1, \"'%s' n'est pas définie\" % (var)\n    function = elem[0][1]\n    assert callable(function) == True, \"le symbole 'puissance' n'est pas une fonction\"\n    return function\n\ndef get_userdefined_variables():\n    return [item for item in dir(sys.modules['moduletotest']) if not item.startswith(\"__\")]\n\ndef get_cleaned_output(out, lines, check = False):\n    output = out.getvalue().strip()\n    l = output.split('\\n')\n    if check == True:\n        assert len(l[-lines:]) == lines, \"Pas assez de lignes affichées !\"\n    return l[-lines:]\n\ndef no_input (*args):\n    raise Exception(\"Aucune entrée utilisateur (input) ne doit être utilisée !\")\n\ndef no_print (*args):\n    raise Exception(\"Aucun affichage (print) ne doit être utilisé !\")\n\nclass Test(TestCase):\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_puissance_is_function(self, input, print):\n        with captured_output() as out:\n            load_module()\n        puissance = get_function(\"puissance\")\n\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_puissance_has_two_params(self, input, print):\n        with captured_output() as out:\n            load_module()\n        puissance = get_function(\"puissance\")\n        sig = signature(puissance)\n        assert len(sig.parameters) == 2, \"La fonction puissance ne prend pas exactement deux paramètres\"\n\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_puissance_should_not_use_builtins(self, input, print):\n        with captured_output() as out:\n            load_module()\n        puissance = get_function(\"puissance\")\n        source = getsource(puissance)\n        assert \"**\" not in source, \"Vous n'avez pas le droit d'utiliser l'opérateur **\"\n        assert \"pow\" not in source, \"Vous n'avez pas le droit d'utiliser la fonction pow()\"\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_puissance_1_1(self, input, print):\n        with captured_output() as out:\n            load_module()\n        puissance = get_function(\"puissance\")\n        assert puissance(1, 1) == 1 ** 1, \"puissance(1, 1) devrait retourner 1\"\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_puissance_2_2(self, input, print):\n        with captured_output() as out:\n            load_module()\n        puissance = get_function(\"puissance\")\n        assert puissance(2, 2) == 2 ** 2, \"puissance(2, 2) devrait retourner 4\"\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_puissance_10_10(self, input, print):\n        with captured_output() as out:\n            load_module()\n        puissance = get_function(\"puissance\")\n        assert puissance(10, 10) == 10 ** 10, \"puissance(10, 10) devrait retourner %d\" % (10 ** 10)\n",
        "solution": "def puissance (entier, exposant):\n    ret = entier\n    for i in range(1, exposant):\n        ret *= entier\n    return ret\n",
        "template_regions": [
          ""
        ],
        "template_regions_rw": [
          0
        ],
        "difficulty": 0,
        "score": 0,
        "creation_date": "2020-02-28T12:32:53.152Z"
      },
      {
        "sequence_id": 1,
        "title": "Calculatrice",
        "lang": "python",
        "instructions": "Concevez une fonction `calculatrice` qui prend en paramètres deux opérandes `x` et\n`y` entières, puis un opérateur `op` (\"\\*\", \"/\", \"+\", ou \"-\"). Retourner le résultat\nde l'opération sous forme d'un nombre à virgule.\n\nSi l'opérateur est \"/\", et que `y` vaut 0, ne pas effectuer l'opération et provoquer\nune [ZeroDivisionError](https://docs.python.org/fr/2/tutorial/errors.html) dont l'argument\nest \"Division par zéro !\"\n\n**NB**: Vous pouvez réutiliser votre code de l'EX05 du TP2. Ici, il s'agit d'être\ncapable de transformer un algorithme avec des entrées utilisateur en une fonction\n",
        "tests": "from unittest.mock import patch\nfrom unittest import TestCase\nfrom inspect import getmembers, signature, getsource\n\nimport sys\nimport imp\nfrom contextlib import contextmanager\nfrom io import StringIO\nimport pytest\n\n@contextmanager\ndef captured_output():\n    new_out = StringIO()\n    old_out = sys.stdout\n    try:\n        sys.stdout = new_out\n        yield sys.stdout\n    finally:\n        sys.stdout = old_out\n\ndef load_module():\n    if 'moduletotest' in sys.modules:\n        imp.reload(sys.modules['moduletotest'])\n    else:\n        import moduletotest\n\ndef check_value(var, value):\n    members = getmembers(sys.modules['moduletotest'])\n    elem = [item for item in members if item[0] == var]\n    assert len(elem) == 1, \"'%s' n'existe pas\" % (var)\n    assert elem[0][1] == value, \"'%s' n'a pas la valeur '%s'\" % (var, value)\n\n\ndef get_function(var):\n    members = getmembers(sys.modules['moduletotest'])\n    elem = [item for item in members if item[0] == var]\n    assert len(elem) == 1, \"'%s' n'est pas définie\" % (var)\n    function = elem[0][1]\n    assert callable(function) == True, \"le symbole 'puissance' n'est pas une fonction\"\n    return function\n\ndef get_userdefined_variables():\n    return [item for item in dir(sys.modules['moduletotest']) if not item.startswith(\"__\")]\n\ndef get_cleaned_output(out, lines, check = False):\n    output = out.getvalue().strip()\n    l = output.split('\\n')\n    if check == True:\n        assert len(l[-lines:]) == lines, \"Pas assez de lignes affichées !\"\n    return l[-lines:]\n\ndef no_input (*args):\n    raise Exception(\"Aucune entrée utilisateur (input) ne doit être utilisée !\")\n\ndef no_print (*args):\n    raise Exception(\"Aucun affichage (print) ne doit être utilisé !\")\n\nclass Test(TestCase):\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_is_function(self, input, print):\n        with captured_output() as out:\n            load_module()\n        calculatrice = get_function(\"calculatrice\")\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_function_params(self, input, print):\n        with captured_output() as out:\n            load_module()\n        calculatrice = get_function(\"calculatrice\")\n        sig = signature(calculatrice)\n        assert len(sig.parameters) == 3, \"Votre fonction calculatrice ne prend pas exactement trois paramètres\"\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_calculatrice_1_plus_1(self, input, print):\n        with captured_output() as out:\n            load_module()\n        calculatrice = get_function(\"calculatrice\")\n        assert calculatrice(1, 1, '+') == 1 + 1, \\\n                \"calculatrice(1, 1, '+') devrait retourner 2\"\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_calculatrice_100_plus_10(self, input, print):\n        with captured_output() as out:\n            load_module()\n        calculatrice = get_function(\"calculatrice\")\n        assert calculatrice(100, 10, '+') == 100 + 10, \\\n                \"calculatrice(100, 10, '+') devrait retourner 110\"\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_calculatrice_1_moins_1(self, input, print):\n        with captured_output() as out:\n            load_module()\n        calculatrice = get_function(\"calculatrice\")\n        assert calculatrice(1, 1, '-') == 1 - 1, \\\n                \"calculatrice(1, 1, '-') devrait retourner 0\"\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_calculatrice_100_moins_10(self, input, print):\n        with captured_output() as out:\n            load_module()\n        calculatrice = get_function(\"calculatrice\")\n        assert calculatrice(100, 10, '-') == 100 - 10, \\\n                \"calculatrice(100, 10, '-') devrait retourner 90\"\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_calculatrice_1_fois_1(self, input, print):\n        with captured_output() as out:\n            load_module()\n        calculatrice = get_function(\"calculatrice\")\n        assert calculatrice(1, 1, '*') == 1 * 1, \\\n                \"calculatrice(1, 1, '*') devrait retourner 1\"\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_calculatrice_100_fois_10(self, input, print):\n        with captured_output() as out:\n            load_module()\n        calculatrice = get_function(\"calculatrice\")\n        assert calculatrice(100, 10, '*') == 100 * 10, \\\n                \"calculatrice(100, 10, '*') devrait retourner 1000\"\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_calculatrice_1_divise_0(self, input, print):\n        with captured_output() as out:\n            load_module()\n        calculatrice = get_function(\"calculatrice\")\n        message = \"calculatrice(1, 0, '/') ne déclenche pas d'erreur de type ZeroDivisionError !\"\n        with pytest.raises(ZeroDivisionError, message=message) as error:\n            calculatrice(1, 0, '/')\n            \n        assert str(error.value) == \"Division par zéro !\", \"Le message de l'erreur n'est pas 'Division par zéro !'\"\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_calculatrice_1_divise_1(self, input, print):\n        with captured_output() as out:\n            load_module()\n        calculatrice = get_function(\"calculatrice\")\n        assert calculatrice(1, 1, '/') == 1 / 1, \\\n                \"calculatrice(1, 1, '/') devrait retourner 1\"\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_calculatrice_100_divise_10(self, input, print):\n        with captured_output() as out:\n            load_module()\n        calculatrice = get_function(\"calculatrice\")\n        assert calculatrice(100, 10, '/') == 100 / 10, \\\n                \"calculatrice(100, 10, '/') devrait retourner 10\"\n",
        "solution": "def calculatrice(x, y, op):\n    if op == '+':\n        return x + y\n    if op == '-':\n        return x - y\n    if op == '*':\n        return x * y\n    if op == '/':\n        if y == 0:\n            raise ZeroDivisionError(\"Division par zéro !\")\n        return x / y\n",
        "template_regions": [
          ""
        ],
        "template_regions_rw": [
          0
        ],
        "difficulty": 0,
        "score": 0,
        "creation_date": "2020-02-28T12:32:53.153Z"
      },
      {
        "sequence_id": 2,
        "title": "Calculatrice explicative",
        "lang": "python",
        "instructions": "Reprenez le code de la question précédente, et transformez-le pour retourner une\nchaîne de caractères à la place d'un nombre entier. Cette chaîne doit être sous la\nforme `{opérande1} {opérateur} {opérande2} = {résultat}`, par ex: `2 x 3 = 6.00`\n\nLe résultat doit être affiché sous la forme d'un nombre à virgule avec une précision au centième.\n\nNote: une façon d'écrire des chaînes de caractères est l'utilisation des chaînes de format, que vous retrouverez avec la fonction printf en c. [Détails](https://realpython.com/python-f-strings/#old-school-string-formatting-in-python)\n\nExemples de chaînes de format\n```\n>>> \"Bonjour {}, vous avez {} chats\".format(\"Monsieur\", 2)\nBonjour Monsieur, vous avez 2 chats\n>>> \"Bonjour {0}, vous avez {1} chats\".format(\"Monsieur\", 2.00)\nBonjour Monsieur, vous avez 2.0 chats\n>>> \"Bonjour {0}, vous avez {1:0.3f} chats\".format(\"Monsieur\", 2)\nBonjour Monsieur, vous avez 2.000 chats\n```\n\nRessources associées: [Floating Point Numbers - Computerphile](https://www.youtube.com/watch?v=PZRI1IfStY0)\n\n",
        "tests": "from unittest.mock import patch\nfrom unittest import TestCase\nfrom inspect import getmembers, signature, getsource\n\nimport sys\nimport imp\nfrom contextlib import contextmanager\nfrom io import StringIO\nimport pytest\n\n@contextmanager\ndef captured_output():\n    new_out = StringIO()\n    old_out = sys.stdout\n    try:\n        sys.stdout = new_out\n        yield sys.stdout\n    finally:\n        sys.stdout = old_out\n\ndef load_module():\n    if 'moduletotest' in sys.modules:\n        imp.reload(sys.modules['moduletotest'])\n    else:\n        import moduletotest\n\ndef check_value(var, value):\n    members = getmembers(sys.modules['moduletotest'])\n    elem = [item for item in members if item[0] == var]\n    assert len(elem) == 1, \"'%s' n'existe pas\" % (var)\n    assert elem[0][1] == value, \"'%s' n'a pas la valeur '%s'\" % (var, value)\n\n\ndef get_function(var):\n    members = getmembers(sys.modules['moduletotest'])\n    elem = [item for item in members if item[0] == var]\n    assert len(elem) == 1, \"'%s' n'est pas définie\" % (var)\n    function = elem[0][1]\n    assert callable(function) == True, \"le symbole 'puissance' n'est pas une fonction\"\n    return function\n\ndef get_userdefined_variables():\n    return [item for item in dir(sys.modules['moduletotest']) if not item.startswith(\"__\")]\n\ndef get_cleaned_output(out, lines, check = False):\n    output = out.getvalue().strip()\n    l = output.split('\\n')\n    if check == True:\n        assert len(l[-lines:]) == lines, \"Pas assez de lignes affichées !\"\n    return l[-lines:]\n\ndef no_input (*args):\n    raise Exception(\"Aucune entrée utilisateur (input) ne doit être utilisée !\")\n\ndef no_print (*args):\n    raise Exception(\"Aucun affichage (print) ne doit être utilisé !\")\n\nclass Test(TestCase):\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_is_function(self, input, print):\n        with captured_output() as out:\n            load_module()\n        calculatrice = get_function(\"calculatrice\")\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_function_params(self, input, print):\n        with captured_output() as out:\n            load_module()\n        calculatrice = get_function(\"calculatrice\")\n        sig = signature(calculatrice)\n        assert len(sig.parameters) == 3, \"Votre fonction calculatrice ne prend pas exactement trois paramètres\"\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_calculatrice_1_plus_1(self, input, print):\n        with captured_output() as out:\n            load_module()\n        calculatrice = get_function(\"calculatrice\")\n        assert calculatrice(1, 1, '+') == '1 + 1 = 2.00', \\\n                \"calculatrice(1, 1, '+') devrait retourner '1 + 1 = 2.00\"\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_calculatrice_100_plus_10(self, input, print):\n        with captured_output() as out:\n            load_module()\n        calculatrice = get_function(\"calculatrice\")\n        assert calculatrice(100, 10, '+') == '100 + 10 = 110.00', \\\n                \"calculatrice(100, 10, '+') devrait retourner '100 + 10 = 110.00'\"\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_calculatrice_1_moins_1(self, input, print):\n        with captured_output() as out:\n            load_module()\n        calculatrice = get_function(\"calculatrice\")\n        assert calculatrice(1, 1, '-') == '1 - 1 = 0.00', \\\n                \"calculatrice(1, 1, '-') devrait retourner '1 - 1 = 0.00'\"\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_calculatrice_100_moins_10(self, input, print):\n        with captured_output() as out:\n            load_module()\n        calculatrice = get_function(\"calculatrice\")\n        assert calculatrice(100, 10, '-') == \"100 - 10 = 90.00\", \\\n                \"calculatrice(100, 10, '-') devrait retourner '100 - 10 = 90.00'\"\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_calculatrice_1_fois_1(self, input, print):\n        with captured_output() as out:\n            load_module()\n        calculatrice = get_function(\"calculatrice\")\n        assert calculatrice(1, 1, '*') == '1 * 1 = 1.00', \\\n                \"calculatrice(1, 1, '*') devrait retourner '1 * 1 = 1.00'\"\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_calculatrice_100_fois_10(self, input, print):\n        with captured_output() as out:\n            load_module()\n        calculatrice = get_function(\"calculatrice\")\n        assert calculatrice(100, 10, '*') == '100 * 10 = 1000.00', \\\n                \"calculatrice(100, 10, '*') devrait retourner '100 * 10 = 1000.00'\"\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_calculatrice_1_divise_0(self, input, print):\n        with captured_output() as out:\n            load_module()\n        calculatrice = get_function(\"calculatrice\")\n        message = \"calculatrice(1, 0, '/') ne déclenche pas d'erreur de type ZeroDivisionError !\"\n        with pytest.raises(ZeroDivisionError, message=message) as error:\n            calculatrice(1, 0, '/')\n            \n        assert str(error.value) == \"Division par zéro !\", \"Le message de l'erreur n'est pas 'Division par zéro !'\"\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_calculatrice_1_divise_1(self, input, print):\n        with captured_output() as out:\n            load_module()\n        calculatrice = get_function(\"calculatrice\")\n        assert calculatrice(1, 1, '/') == '1 / 1 = 1.00', \\\n                \"calculatrice(1, 1, '/') devrait retourner '1 / 1 = 1.00'\"\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_calculatrice_100_divise_10(self, input, print):\n        with captured_output() as out:\n            load_module()\n        calculatrice = get_function(\"calculatrice\")\n        assert calculatrice(100, 10, '/') == '100 / 10 = 10.00', \\\n                \"calculatrice(100, 10, '/') devrait retourner '100 / 10 = 10.00'\"\n",
        "solution": "def calculatrice(x, y, op):\n    if op == '+':\n        return \"%d + %d = %0.2f\" % (x, y, x + y)\n    if op == '-':\n        return \"%d - %d = %0.2f\" % (x, y, x - y)\n    if op == '*':\n        return \"%d * %d = %0.2f\" % (x, y, x * y)\n    if op == '/':\n        if y == 0:\n            raise ZeroDivisionError(\"Division par zéro !\")\n        return \"%d / %d = %0.2f\" % (x, y, x / y)\n",
        "template_regions": [
          ""
        ],
        "template_regions_rw": [
          0
        ],
        "difficulty": 0,
        "score": 0,
        "creation_date": "2020-02-28T12:32:53.154Z"
      },
      {
        "sequence_id": 3,
        "title": "Fonction carré",
        "lang": "python",
        "instructions": "Concevez une fonction `carres_jusqua` qui prend en paramètre un nombre entier `n` et\nqui retourne tous les carrés jusqu'à n inclus, en réutilisant la fonction `puissance`\nconçue dans l'EX01. Chacun des résultats doit être séparé d'un retour à la ligne.\n\n\nExemple:\n```\n>>> carres_jusqua(10)\n0\n1\n4\n9\n16\n25\n36\n49\n64\n81\n100\n```\n",
        "tests": "from unittest.mock import patch\nfrom unittest import TestCase\nfrom inspect import getmembers, signature, getsource\n\nimport sys\nimport imp\nfrom contextlib import contextmanager\nfrom io import StringIO\nimport pytest\n\n@contextmanager\ndef captured_output():\n    new_out = StringIO()\n    old_out = sys.stdout\n    try:\n        sys.stdout = new_out\n        yield sys.stdout\n    finally:\n        sys.stdout = old_out\n\ndef load_module():\n    if 'moduletotest' in sys.modules:\n        imp.reload(sys.modules['moduletotest'])\n    else:\n        import moduletotest\n\ndef check_value(var, value):\n    members = getmembers(sys.modules['moduletotest'])\n    elem = [item for item in members if item[0] == var]\n    assert len(elem) == 1, \"'%s' n'existe pas\" % (var)\n    assert elem[0][1] == value, \"'%s' n'a pas la valeur '%s'\" % (var, value)\n\n\ndef get_function(var):\n    members = getmembers(sys.modules['moduletotest'])\n    elem = [item for item in members if item[0] == var]\n    assert len(elem) == 1, \"'%s' n'est pas définie\" % (var)\n    function = elem[0][1]\n    assert callable(function) == True, \"le symbole 'puissance' n'est pas une fonction\"\n    return function\n\ndef get_userdefined_variables():\n    return [item for item in dir(sys.modules['moduletotest']) if not item.startswith(\"__\")]\n\ndef get_cleaned_output(out, lines, check = False):\n    output = out.getvalue().strip()\n    l = output.split('\\n')\n    if check == True:\n        assert len(l[-lines:]) == lines, \"Pas assez de lignes affichées !\"\n    return l[-lines:]\n\ndef no_input (*args):\n    raise Exception(\"Aucune entrée utilisateur (input) ne doit être utilisée !\")\n\ndef no_print (*args):\n    raise Exception(\"Aucun affichage (print) ne doit être utilisé !\")\n\nclass Test(TestCase):\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_is_function(self, input, print):\n        with captured_output() as out:\n            load_module()\n        carres_jusqua = get_function(\"carres_jusqua\")\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_function_params(self, input, print):\n        with captured_output() as out:\n            load_module()\n        carres_jusqua = get_function(\"carres_jusqua\")\n        sig = signature(carres_jusqua)\n        assert len(sig.parameters) == 1, \"Votre fonction carres_jusqua ne prend pas exactement un paramètre\"\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_function_code(self, input, print):\n        with captured_output() as out:\n            load_module()\n        carres_jusqua = get_function(\"carres_jusqua\")\n        source = getsource(carres_jusqua)\n        assert \"puissance(\" in source, \"Votre fonction carres_jusqua ne fait pas usage de votre fonction puissance\"\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_n_1(self, input, print):\n        with captured_output() as out:\n            load_module()\n        carres_jusqua = get_function(\"carres_jusqua\")\n        assert carres_jusqua(1) == \"0\\n1\", \\\n                \"carres_jusqua(1) devrait retourner: '0\\\\n1'\"\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_n_5(self, input, print):\n        with captured_output() as out:\n            load_module()\n        carres_jusqua = get_function(\"carres_jusqua\")\n        assert carres_jusqua(5) == \"0\\n1\\n4\\n9\\n16\\n25\", \\\n                \"carres_jusqua(5) devrait retourner: '0\\\\n1\\\\n4\\\\n9\\\\n16\\\\n25'\"\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_n_15(self, input, print):\n        with captured_output() as out:\n            load_module()\n        carres_jusqua = get_function(\"carres_jusqua\")\n        assert carres_jusqua(15) == \"0\\n1\\n4\\n9\\n16\\n25\\n36\\n49\\n64\\n81\\n100\\n121\\n144\\n169\\n196\\n225\", \\\n                \"carres_jusqua(15) devrait retourner: '0\\\\n1\\\\n4\\\\n9\\\\n16\\\\n25\\\\n36\\\\n49\\\\n64\\\\n81\\\\n100\\\\n121\\\\n144\\\\n169\\\\n196\\\\n225'\"\n",
        "solution": "def puissance(entier, exposant):\n    ret = entier\n    for i in range(1, exposant):\n        ret *= entier\n    return ret\n\ndef carres_jusqua(n):\n    ret = \"\"\n    for i in range(0, n + 1):\n        ret += str(puissance(i, 2)) + (\"\\n\" if i < n else \"\")\n    return ret\n\n# print(carres_jusqua(int(input())))\n",
        "template_regions": [
          ""
        ],
        "template_regions_rw": [
          0
        ],
        "difficulty": 0,
        "score": 0,
        "creation_date": "2020-02-28T12:32:53.154Z"
      },
      {
        "sequence_id": 4,
        "title": "Maximum",
        "lang": "python",
        "instructions": "Concevez une fonction \"maximum\" qui prend 3 nombres entiers en argument, et qui retourne le paramètre qui a la plus grande valeur, sans utiliser la fonction prédéfinie max().\n\nPour aller plus loin: Concevez une fonction maximum\\_generic qui accepte un [nombre arbitraire d'arguments](https://www.digitalocean.com/community/tutorials/how-to-use-args-and-kwargs-in-python-3) et qui retourne l'argument avec la valeur la plus grande.\n",
        "tests": "from unittest.mock import patch\nfrom unittest import TestCase\nfrom inspect import getmembers, signature, getsource\n\nimport sys\nimport imp\nfrom contextlib import contextmanager\nfrom io import StringIO\nimport pytest\n\n@contextmanager\ndef captured_output():\n    new_out = StringIO()\n    old_out = sys.stdout\n    try:\n        sys.stdout = new_out\n        yield sys.stdout\n    finally:\n        sys.stdout = old_out\n\ndef load_module():\n    if 'moduletotest' in sys.modules:\n        imp.reload(sys.modules['moduletotest'])\n    else:\n        import moduletotest\n\ndef check_value(var, value):\n    members = getmembers(sys.modules['moduletotest'])\n    elem = [item for item in members if item[0] == var]\n    assert len(elem) == 1, \"'%s' n'existe pas\" % (var)\n    assert elem[0][1] == value, \"'%s' n'a pas la valeur '%s'\" % (var, value)\n\n\ndef get_function(var):\n    members = getmembers(sys.modules['moduletotest'])\n    elem = [item for item in members if item[0] == var]\n    assert len(elem) == 1, \"'%s' n'est pas définie\" % (var)\n    function = elem[0][1]\n    assert callable(function) == True, \"le symbole 'puissance' n'est pas une fonction\"\n    return function\n\ndef get_userdefined_variables():\n    return [item for item in dir(sys.modules['moduletotest']) if not item.startswith(\"__\")]\n\ndef get_cleaned_output(out, lines, check = False):\n    output = out.getvalue().strip()\n    l = output.split('\\n')\n    if check == True:\n        assert len(l[-lines:]) == lines, \"Pas assez de lignes affichées !\"\n    return l[-lines:]\n\ndef no_input (*args):\n    raise Exception(\"Aucune entrée utilisateur (input) ne doit être utilisée !\")\n\ndef no_print (*args):\n    raise Exception(\"Aucun affichage (print) ne doit être utilisé !\")\n\nclass Test(TestCase):\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_is_function(self, input, print):\n        with captured_output() as out:\n            load_module()\n        maximum = get_function(\"maximum\")\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_function_params(self, input, print):\n        with captured_output() as out:\n            load_module()\n        maximum = get_function(\"maximum\")\n        sig = signature(maximum)\n        assert len(sig.parameters) == 3, \"Votre fonction maximum ne prend pas exactement un paramètre\"\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_function_code(self, input, print):\n        with captured_output() as out:\n            load_module()\n        maximum = get_function(\"maximum\")\n        source = getsource(maximum)\n        assert \"max(\" not in source, \"Votre fonction carres_jusqua ne doit pas faire usage de la fonction max\"\n        assert \"sort(\" not in source, \"Votre fonction carres_jusqua ne doit pas faire usage de la fonction sort\"\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_1_2_3(self, input, print):\n        with captured_output() as out:\n            load_module()\n        maximum = get_function(\"maximum\")\n        assert maximum(1, 2, 3) == 3, \\\n                \"maximum(1, 2, 3) devrait retourner: 3\"\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_2_1_3(self, input, print):\n        with captured_output() as out:\n            load_module()\n        maximum = get_function(\"maximum\")\n        assert maximum(2, 1, 3) == 3, \\\n                \"maximum(2, 1, 3) devrait retourner: 3\"\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_2_2_3(self, input, print):\n        with captured_output() as out:\n            load_module()\n        maximum = get_function(\"maximum\")\n        assert maximum(2, 2, 3) == 3, \\\n                \"maximum(2, 2, 3) devrait retourner: 3\"\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_4_2_1(self, input, print):\n        with captured_output() as out:\n            load_module()\n        maximum = get_function(\"maximum\")\n        assert maximum(4, 2, 1) == 4, \\\n                \"maximum(4, 2, 1) devrait retourner: 4\"\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_4_1_2(self, input, print):\n        with captured_output() as out:\n            load_module()\n        maximum = get_function(\"maximum\")\n        assert maximum(4, 1, 2) == 4, \\\n                \"maximum(4, 1, 2) devrait retourner: 4\"\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_4_2_2(self, input, print):\n        with captured_output() as out:\n            load_module()\n        maximum = get_function(\"maximum\")\n        assert maximum(4, 2, 2) == 4, \\\n                \"maximum(4, 2, 2) devrait retourner: 4\"\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_1_2_5(self, input, print):\n        with captured_output() as out:\n            load_module()\n        maximum = get_function(\"maximum\")\n        assert maximum(1, 2, 5) == 5, \\\n                \"maximum(1, 2, 5) devrait retourner: 5\"\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_2_2_5(self, input, print):\n        with captured_output() as out:\n            load_module()\n        maximum = get_function(\"maximum\")\n        assert maximum(2, 2, 5) == 5, \\\n                \"maximum(2, 2, 5) devrait retourner: 5\"\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_2_1_5(self, input, print):\n        with captured_output() as out:\n            load_module()\n        maximum = get_function(\"maximum\")\n        assert maximum(2, 1, 5) == 5, \\\n                \"maximum(2, 1, 5) devrait retourner: 5\"\n",
        "solution": "def maximum(a, b, c):\n    if a <= c or b <= c:\n        return c\n    if a <= b and c <= b:\n        return b\n    return a\n",
        "template_regions": [
          ""
        ],
        "template_regions_rw": [
          0
        ],
        "difficulty": 0,
        "score": 0,
        "creation_date": "2020-02-28T12:32:53.155Z"
      },
      {
        "sequence_id": 5,
        "title": "Moyenne",
        "lang": "python",
        "instructions": "Concevez une fonction `moyenne`, qui prend 5 nombres à virgule en argument, qui\nretourne la moyenne de ces nombres, mais qui ne compte pas les nombres dont la valeur est -1.\n\nEx:\n```\nmoyenne (1.0, 2.0, 3.0, 4.0, 5.0) # 3.0\nmoyenne (1.0, 2.0, 3.0, 4.0, -1) # 2.5\nmoyenne (15.0, -1, 3.0, 4.0, -1) # 7.33333...\n```\n",
        "tests": "from unittest.mock import patch\nfrom unittest import TestCase\nfrom inspect import getmembers, signature, getsource\n\nimport sys\nimport imp\nfrom contextlib import contextmanager\nfrom io import StringIO\nimport pytest\n\n@contextmanager\ndef captured_output():\n    new_out = StringIO()\n    old_out = sys.stdout\n    try:\n        sys.stdout = new_out\n        yield sys.stdout\n    finally:\n        sys.stdout = old_out\n\ndef load_module():\n    if 'moduletotest' in sys.modules:\n        imp.reload(sys.modules['moduletotest'])\n    else:\n        import moduletotest\n\ndef check_value(var, value):\n    members = getmembers(sys.modules['moduletotest'])\n    elem = [item for item in members if item[0] == var]\n    assert len(elem) == 1, \"'%s' n'existe pas\" % (var)\n    assert elem[0][1] == value, \"'%s' n'a pas la valeur '%s'\" % (var, value)\n\n\ndef get_function(var):\n    members = getmembers(sys.modules['moduletotest'])\n    elem = [item for item in members if item[0] == var]\n    assert len(elem) == 1, \"'%s' n'est pas définie\" % (var)\n    function = elem[0][1]\n    assert callable(function) == True, \"le symbole 'puissance' n'est pas une fonction\"\n    return function\n\ndef get_userdefined_variables():\n    return [item for item in dir(sys.modules['moduletotest']) if not item.startswith(\"__\")]\n\ndef get_cleaned_output(out, lines, check = False):\n    output = out.getvalue().strip()\n    l = output.split('\\n')\n    if check == True:\n        assert len(l[-lines:]) == lines, \"Pas assez de lignes affichées !\"\n    return l[-lines:]\n\ndef no_input (*args):\n    raise Exception(\"Aucune entrée utilisateur (input) ne doit être utilisée !\")\n\ndef no_print (*args):\n    raise Exception(\"Aucun affichage (print) ne doit être utilisé !\")\n\nclass Test(TestCase):\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_is_function(self, input, print):\n        with captured_output() as out:\n            load_module()\n        moyenne = get_function(\"moyenne\")\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_function_params(self, input, print):\n        with captured_output() as out:\n            load_module()\n        moyenne = get_function(\"moyenne\")\n        sig = signature(moyenne)\n        assert len(sig.parameters) == 5, \"Votre fonction moyenne ne prend pas exactement cinq paramètres\"\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_1_2_3_4_5(self, input, print):\n        with captured_output() as out:\n            load_module()\n        moyenne = get_function(\"moyenne\")\n        assert moyenne(1, 2, 3, 4, 5) == (1 + 2 + 3 + 4 + 5) / 5, \\\n                \"moyenne(1, 2, 3, 4, 5) devrait retourner: %f\" % ((1 + 2 + 3 + 4 + 5) / 5)\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_x_2_3(self, input, print):\n        with captured_output() as out:\n            load_module()\n        moyenne = get_function(\"moyenne\")\n        assert moyenne(-1, 2, 3, -1, -1) == (2 + 3) / 2, \\\n                \"moyenne(-1, 2, 3, -1, -1) devrait retourner: %f\" % ((2 + 3) / 2)\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_3_x_3(self, input, print):\n        with captured_output() as out:\n            load_module()\n        moyenne = get_function(\"moyenne\")\n        assert moyenne(3, -1, 3, -1, -1) == (3 + 3) / 2, \\\n                \"moyenne(3, -1, 3, -1, -1) devrait retourner: %f\" % ((3 + 3) / 2)\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_4_x_x(self, input, print):\n        with captured_output() as out:\n            load_module()\n        moyenne = get_function(\"moyenne\")\n        assert moyenne(4, -1, -1, -1, -1) == 4 / 1, \\\n                \"moyenne(4, -1, -1, -1, -1) devrait retourner: %f\" % (4 / 1)\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_x_x_5(self, input, print):\n        with captured_output() as out:\n            load_module()\n        moyenne = get_function(\"moyenne\")\n        assert moyenne(-1, -1, 5, -1, -1) == 5 / 1, \\\n                \"moyenne(-1, -1, 5, -1, -1) devrait retourner: %f\" % (5 / 1)\n",
        "solution": "def moyenne(a, b, c, d, e):\n    nbr = 0\n    total = 0\n    if a != -1:\n        nbr += 1\n        total += a\n    if b != -1:\n        nbr += 1\n        total += b\n    if c != -1:\n        nbr += 1\n        total += c\n    if d != -1:\n        nbr += 1\n        total += d\n    if e != -1:\n        nbr += 1\n        total += e\n\n    return total / nbr\n",
        "template_regions": [
          ""
        ],
        "template_regions_rw": [
          0
        ],
        "difficulty": 0,
        "score": 0,
        "creation_date": "2020-02-28T12:32:53.156Z"
      },
      {
        "sequence_id": 6,
        "title": "Ordre alphabétique",
        "lang": "python",
        "instructions": "*Introduction aux listes*\nConcevez une fonction `tri` qui prend en argument une chaîne de caractères, et qui retourne une nouvelle chaîne dont les caractères sont triés par ordre alphabétique.\n\nEx:\n```\ntri(\"zyxwvutsrqponmlkjihgfedcba\") # abcdefghijklmnopqrstuvwxyz\n```\n",
        "tests": "from unittest.mock import patch\nfrom unittest import TestCase\nfrom inspect import getmembers, signature, getsource\n\nimport sys\nimport imp\nfrom contextlib import contextmanager\nfrom io import StringIO\nimport pytest\n\n@contextmanager\ndef captured_output():\n    new_out = StringIO()\n    old_out = sys.stdout\n    try:\n        sys.stdout = new_out\n        yield sys.stdout\n    finally:\n        sys.stdout = old_out\n\ndef load_module():\n    if 'moduletotest' in sys.modules:\n        imp.reload(sys.modules['moduletotest'])\n    else:\n        import moduletotest\n\ndef check_value(var, value):\n    members = getmembers(sys.modules['moduletotest'])\n    elem = [item for item in members if item[0] == var]\n    assert len(elem) == 1, \"'%s' n'existe pas\" % (var)\n    assert elem[0][1] == value, \"'%s' n'a pas la valeur '%s'\" % (var, value)\n\n\ndef get_function(var):\n    members = getmembers(sys.modules['moduletotest'])\n    elem = [item for item in members if item[0] == var]\n    assert len(elem) == 1, \"'%s' n'est pas définie\" % (var)\n    function = elem[0][1]\n    assert callable(function) == True, \"le symbole 'puissance' n'est pas une fonction\"\n    return function\n\ndef get_userdefined_variables():\n    return [item for item in dir(sys.modules['moduletotest']) if not item.startswith(\"__\")]\n\ndef get_cleaned_output(out, lines, check = False):\n    output = out.getvalue().strip()\n    l = output.split('\\n')\n    if check == True:\n        assert len(l[-lines:]) == lines, \"Pas assez de lignes affichées !\"\n    return l[-lines:]\n\ndef no_input (*args):\n    raise Exception(\"Aucune entrée utilisateur (input) ne doit être utilisée !\")\n\ndef no_print (*args):\n    raise Exception(\"Aucun affichage (print) ne doit être utilisé !\")\n\nclass Test(TestCase):\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_is_function(self, input, print):\n        with captured_output() as out:\n            load_module()\n        tri = get_function(\"tri\")\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_function_params(self, input, print):\n        with captured_output() as out:\n            load_module()\n        tri = get_function(\"tri\")\n        sig = signature(tri)\n        assert len(sig.parameters) == 1, \"Votre fonction moyenne ne prend pas exactement un paramètre\"\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_alphabet(self, input, print):\n        with captured_output() as out:\n            load_module()\n        tri = get_function(\"tri\")\n        assert tri(\"zyxwvutsrqponmlkjihgfedcba\") == \"abcdefghijklmnopqrstuvwxyz\", \\\n                \"tri('zyxwvutsrqponmlkjihgfedcba') devrait retourner: 'abcdefghijklmnopqrstuvwxyz'\"\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_bonjour(self, input, print):\n        with captured_output() as out:\n            load_module()\n        tri = get_function(\"tri\")\n        assert tri(\"bonjour\") == \"bjnooru\", \\\n                \"tri('bonjour') devrait retourner: 'bjnooru'\"\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_alphabet2(self, input, print):\n        with captured_output() as out:\n            load_module()\n        tri = get_function(\"tri\")\n        assert tri(\"alphabet\") == \"aabehlpt\", \\\n                \"tri('alphabet') devrait retourner: 'aabehlpt'\"\n",
        "solution": "def tri (string):\n    ret = ''\n    el = ''\n    pos = 0\n    while (len(string)):\n        el = string[0]\n        pos = 0\n        for j, key2 in enumerate(string):\n            if (key2 < el):\n                el = key2\n                pos = j\n        string = string[:pos] + string[(pos + 1):]\n        ret += el\n    return ret\n\n# print(tri(input()))\n",
        "template_regions": [
          ""
        ],
        "template_regions_rw": [
          0
        ],
        "difficulty": 0,
        "score": 0,
        "creation_date": "2020-02-28T12:32:53.156Z"
      },
      {
        "sequence_id": 7,
        "title": "Compression",
        "lang": "python",
        "instructions": "Concevez une fonction `compression` qui prend en paramètre une chaîne de caractères,\nqui trie la chaîne grâce à la fonction `tri` précédement écrite, et qui remplace\ntoute succession de lettres identiques par le nombre suivi de la lettre, sauf si la\nlettre n'apparaît qu'une seule fois, auquel cas elle ne doit pas être précédée d'un\nnombre.\n\nEx:\n```\n'abbcccdd' => 'a2b3c2d'\n'abcd' => 'abcd'\n'aaaaaaaa' => '8a'\n```\n",
        "tests": "from unittest.mock import patch\nfrom unittest import TestCase\nfrom inspect import getmembers, signature, getsource\n\nimport sys\nimport imp\nfrom contextlib import contextmanager\nfrom io import StringIO\nimport pytest\n\n@contextmanager\ndef captured_output():\n    new_out = StringIO()\n    old_out = sys.stdout\n    try:\n        sys.stdout = new_out\n        yield sys.stdout\n    finally:\n        sys.stdout = old_out\n\ndef load_module():\n    if 'moduletotest' in sys.modules:\n        imp.reload(sys.modules['moduletotest'])\n    else:\n        import moduletotest\n\ndef check_value(var, value):\n    members = getmembers(sys.modules['moduletotest'])\n    elem = [item for item in members if item[0] == var]\n    assert len(elem) == 1, \"'%s' n'existe pas\" % (var)\n    assert elem[0][1] == value, \"'%s' n'a pas la valeur '%s'\" % (var, value)\n\n\ndef get_function(var):\n    members = getmembers(sys.modules['moduletotest'])\n    elem = [item for item in members if item[0] == var]\n    assert len(elem) == 1, \"'%s' n'est pas définie\" % (var)\n    function = elem[0][1]\n    assert callable(function) == True, \"le symbole 'puissance' n'est pas une fonction\"\n    return function\n\ndef get_userdefined_variables():\n    return [item for item in dir(sys.modules['moduletotest']) if not item.startswith(\"__\")]\n\ndef get_cleaned_output(out, lines, check = False):\n    output = out.getvalue().scompressionp()\n    l = output.split('\\n')\n    if check == True:\n        assert len(l[-lines:]) == lines, \"Pas assez de lignes affichées !\"\n    return l[-lines:]\n\ndef no_input (*args):\n    raise Exception(\"Aucune entrée utilisateur (input) ne doit être utilisée !\")\n\ndef no_print (*args):\n    raise Exception(\"Aucun affichage (print) ne doit être utilisé !\")\n\nclass Test(TestCase):\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_is_function(self, input, print):\n        with captured_output() as out:\n            load_module()\n        compression = get_function(\"compression\")\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_function_params(self, input, print):\n        with captured_output() as out:\n            load_module()\n        compression = get_function(\"compression\")\n        sig = signature(compression)\n        assert len(sig.parameters) == 1, \"Votre fonction moyenne ne prend pas exactement un paramètre\"\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_alphabet(self, input, print):\n        with captured_output() as out:\n            load_module()\n        compression = get_function(\"compression\")\n        assert compression(\"zyxwvutsrqponmlkjihgfedcba\") == \"abcdefghijklmnopqrstuvwxyz\", \\\n                \"compression('zyxwvutsrqponmlkjihgfedcba') devrait retourner: 'abcdefghijklmnopqrstuvwxyz'\"\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_bonjour(self, input, print):\n        with captured_output() as out:\n            load_module()\n        compression = get_function(\"compression\")\n        assert compression(\"bonjour\") == \"bjn2oru\", \\\n                \"compression('bonjour') devrait retourner: 'bjn2oru'\"\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_alphabet2(self, input, print):\n        with captured_output() as out:\n            load_module()\n        compression = get_function(\"compression\")\n        assert compression(\"alphabet\") == \"2abehlpt\", \\\n                \"compression('alphabet') devrait retourner: '2abehlpt'\"\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_adoprixtoxis(self, input, print):\n        with captured_output() as out:\n            load_module()\n        compression = get_function(\"compression\")\n        assert compression(\"adoprixtoxis\") == \"ad2i2oprst2x\", \\\n                \"compression('adoprixtoxis') devrait retourner: 'ad2i2oprst2x'\"\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_a_la_claire_fontaine(self, input, print):\n        with captured_output() as out:\n            load_module()\n        compression = get_function(\"compression\")\n        assert compression(\"a la claire fontaine\") == \"3 4ac2ef2i2l2nort\", \\\n                \"compression('a la claire fontaine') devrait retourner: '3 4ac2ef2i2l2nort'\"\n",
        "solution": "def tri (string):\n    ret = ''\n    el = ''\n    pos = 0\n    while (len(string)):\n        el = string[0]\n        pos = 0\n        for j, key2 in enumerate(string):\n            if (key2 < el):\n                el = key2\n                pos = j\n        string = string[:pos] + string[(pos + 1):]\n        ret += el\n    return ret\n\ndef addto (counter, current):\n    if (counter == 1):\n        return current\n    else:\n        return str(counter) + current\n\ndef compression (string):\n    string = tri(string)\n    ret = ''\n    counter = 0\n    current = string[0]\n    for i in string:\n        if (current == i):\n            counter += 1\n        else:\n            ret += addto(counter, current)\n            current = i\n            counter = 1\n    ret += addto(counter, current)\n    return ret\n\n# print(compression(input()))\n",
        "template_regions": [
          ""
        ],
        "template_regions_rw": [
          0
        ],
        "difficulty": 0,
        "score": 0,
        "creation_date": "2020-02-28T12:32:53.157Z"
      },
      {
        "sequence_id": 8,
        "title": "Hexadecimal",
        "lang": "python",
        "instructions": "Concevez une fonction qui prend en entrée une chaîne de caractères [ASCII](https://fr.wikipedia.org/wiki/American_Standard_Code_for_Information_Interchange) et qui la convertit en une chaîne de caractères hexadécimale, autrement appelée [base16](https://tools.ietf.org/html/rfc4648)\n\nPour rappel, chaque caractère a une représentation particulière en mémoire.\nPar exemple, le A a une valeur de 65, ou 0x40 en hexadécimal\n\nLa chaîne de caractères résultante ne doit contenir que des nombres et des lettres\n**majuscules**.\n\nVous devez concevoir l'algorithme vous-même sans vous appuyer sur les fonctions prédéfinies comme le module base64.\n\nExemples:\n```\nABCDE    => 4142434445\n bonjour => 20626F6E6A6F7572\n```\n",
        "tests": "from unittest.mock import patch\nfrom unittest import TestCase\nfrom inspect import getmembers, signature, getsource\n\nimport sys\nimport imp\nfrom contextlib import contextmanager\nfrom io import StringIO\nimport pytest\n\n@contextmanager\ndef captured_output():\n    new_out = StringIO()\n    old_out = sys.stdout\n    try:\n        sys.stdout = new_out\n        yield sys.stdout\n    finally:\n        sys.stdout = old_out\n\ndef load_module():\n    if 'moduletotest' in sys.modules:\n        imp.reload(sys.modules['moduletotest'])\n    else:\n        import moduletotest\n\ndef check_value(var, value):\n    members = getmembers(sys.modules['moduletotest'])\n    elem = [item for item in members if item[0] == var]\n    assert len(elem) == 1, \"'%s' n'existe pas\" % (var)\n    assert elem[0][1] == value, \"'%s' n'a pas la valeur '%s'\" % (var, value)\n\n\ndef get_function(var):\n    members = getmembers(sys.modules['moduletotest'])\n    elem = [item for item in members if item[0] == var]\n    assert len(elem) == 1, \"'%s' n'est pas définie\" % (var)\n    function = elem[0][1]\n    assert callable(function) == True, \"le symbole 'puissance' n'est pas une fonction\"\n    return function\n\ndef get_userdefined_variables():\n    return [item for item in dir(sys.modules['moduletotest']) if not item.startswith(\"__\")]\n\ndef get_cleaned_output(out, lines, check = False):\n    output = out.getvalue().scompressionp()\n    l = output.split('\\n')\n    if check == True:\n        assert len(l[-lines:]) == lines, \"Pas assez de lignes affichées !\"\n    return l[-lines:]\n\ndef no_input (*args):\n    raise Exception(\"Aucune entrée utilisateur (input) ne doit être utilisée !\")\n\ndef no_print (*args):\n    raise Exception(\"Aucun affichage (print) ne doit être utilisé !\")\n\nclass Test(TestCase):\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_is_function(self, input, print):\n        with captured_output() as out:\n            load_module()\n        hexadecimal = get_function(\"hexadecimal\")\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_function_params(self, input, print):\n        with captured_output() as out:\n            load_module()\n        hexadecimal = get_function(\"hexadecimal\")\n        sig = signature(hexadecimal)\n        assert len(sig.parameters) == 1, \"Votre fonction moyenne ne prend pas exactement un paramètre\"\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_function_code(self, input, print):\n        with captured_output() as out:\n            load_module()\n        hexadecimal = get_function(\"hexadecimal\")\n        source = getsource(hexadecimal)\n        assert \"hex(\" not in source, \"Votre fonction hexadecimal ne doit pas faire usage de la fonction hex()\"\n        assert \"encode(\" not in source, \"Votre fonction hexadecimal ne doit pas faire usage de la fonction encode()\"\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_alpha(self, input, print):\n        with captured_output() as out:\n            load_module()\n        hexadecimal = get_function(\"hexadecimal\")\n        assert hexadecimal(\"alpha\") == '616C706861', \\\n                \"hexadecimal('alpha') devrait retourner: '616C706861'\"\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_gjrkaemejrnerh(self, input, print):\n        with captured_output() as out:\n            load_module()\n        hexadecimal = get_function(\"hexadecimal\")\n        assert hexadecimal(\"gjrkaemejrnerh\") == '676A726B61656D656A726E657268', \\\n                \"hexadecimal('gjrkaemejrnerh') devrait retourner: '676A726B61656D656A726E657268'\"\n",
        "solution": "full = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F']\ndef hexadecimal (string):\n    out = ''\n    for i in string:\n        interm = int(ord(i))\n        up = (interm & 0xF0) >> 4\n        out += full[up]\n        down = interm & 0x0F\n        out += full[down]\n    return out\n",
        "template_regions": [
          ""
        ],
        "template_regions_rw": [
          0
        ],
        "difficulty": 0,
        "score": 0,
        "creation_date": "2020-02-28T12:32:53.158Z"
      }
    ]
  },
  {
    "name": "TP5",
    "exercises": [
      {
        "sequence_id": 0,
        "title": "Calcul du nombre d'occurences",
        "lang": "python",
        "instructions": "Écrire une fonction `negatifs` qui reçoit un tableau de 10 nombres entiers en paramètre, puis qui calcule la quantité de nombres négatifs dans le tableau.\n\nLa fonction doit retourner la quantité de nombres négatifs comptés.\n",
        "tests": "from unittest.mock import patch\nfrom unittest import TestCase\nfrom inspect import getmembers, signature, getsource\n\nimport sys\nimport imp\nfrom contextlib import contextmanager\nfrom io import StringIO\nimport pytest\n\n@contextmanager\ndef captured_output():\n    new_out = StringIO()\n    old_out = sys.stdout\n    try:\n        sys.stdout = new_out\n        yield sys.stdout\n    finally:\n        sys.stdout = old_out\n\ndef load_module():\n    if 'moduletotest' in sys.modules:\n        imp.reload(sys.modules['moduletotest'])\n    else:\n        import moduletotest\n\ndef check_value(var, value):\n    members = getmembers(sys.modules['moduletotest'])\n    elem = [item for item in members if item[0] == var]\n    assert len(elem) == 1, \"'%s' n'existe pas\" % (var)\n    assert elem[0][1] == value, \"'%s' n'a pas la valeur '%s'\" % (var, value)\n\n\ndef get_function(var):\n    members = getmembers(sys.modules['moduletotest'])\n    elem = [item for item in members if item[0] == var]\n    assert len(elem) == 1, \"'%s' n'est pas définie\" % (var)\n    function = elem[0][1]\n    assert callable(function) == True, \"le symbole 'puissance' n'est pas une fonction\"\n    return function\n\ndef get_userdefined_variables():\n    return [item for item in dir(sys.modules['moduletotest']) if not item.startswith(\"__\")]\n\ndef get_cleaned_output(out, lines, check = False):\n    output = out.getvalue().scompressionp()\n    l = output.split('\\n')\n    if check == True:\n        assert len(l[-lines:]) == lines, \"Pas assez de lignes affichées !\"\n    return l[-lines:]\n\ndef no_input (*args):\n    raise Exception(\"Aucune entrée utilisateur (input) ne doit être utilisée !\")\n\ndef no_print (*args):\n    raise Exception(\"Aucun affichage (print) ne doit être utilisé !\")\n\nclass Test(TestCase):\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_is_function(self, input, print):\n        with captured_output() as out:\n            load_module()\n        negatifs = get_function(\"negatifs\")\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_function_params(self, input, print):\n        with captured_output() as out:\n            load_module()\n        sig = signature(get_function(\"negatifs\"))\n        assert len(sig.parameters) == 1, \"Votre fonction negatifs ne prend pas exactement un paramètre\"\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_zero(self, input, print):\n        with captured_output() as out:\n            load_module()\n        negatifs = get_function(\"negatifs\")\n        ret = negatifs([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n        assert ret == 0, \\\n                \"negatifs([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) devrait retourner: 0 mais a retourné \" + str(ret)\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_trois(self, input, print):\n        with captured_output() as out:\n            load_module()\n        negatifs = get_function(\"negatifs\")\n        ret = negatifs([1, 2, -1, 4, -1, 6, -1, 8, 9, 10])\n        assert ret == 3, \\\n                \"negatifs([1, 2, -1, 4, -1, 6, -1, 8, 9, 10]) devrait retourner: 3 mais a retourné \" + str(ret)\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_cinq(self, input, print):\n        with captured_output() as out:\n            load_module()\n        negatifs = get_function(\"negatifs\")\n        ret = negatifs([1, 2, -5, -11, -26, -22, 0, 0, 0, -18])\n        assert ret == 5, \\\n                \"negatifs([1, 2, -5, -11, -26, -22, 0, 0, 0, -18]) devrait retourner: 5 mais a retourné \" + str(ret)\n\n\n",
        "solution": "def negatifs (liste):\n    count = 0\n    for i in liste:\n        if i < 0:\n            count += 1\n    return count\n",
        "template_regions": [
          ""
        ],
        "template_regions_rw": [
          0
        ],
        "difficulty": 0,
        "score": 0,
        "creation_date": "2020-02-28T12:32:53.159Z"
      },
      {
        "sequence_id": 1,
        "title": "Moyenne sur plusieurs séries de nombres",
        "lang": "python",
        "instructions": "Écrire la fonction `moyenne_series` qui calcule la moyenne de plusieurs séries de nombres.\nElle reçoit en paramètre un tableau qui contient les différentes séries à calculer, donc un tableau à deux dimensions\nÀ la fin du programme, retourner une chaîne de caractères qui contient les différents résultats sous la forme:\n```\nS{1}: {moy1}\nS{2}: {moy2}\nS{3}: {moy3}\n...\nS{n}: {moyn}\n```\noù {moyn} doit être affiché avec une précision au dixième.\n\nExemple:\n```python\nseries = [\n  [10, 7, 16, 8, 11],\n  [2, 20, 3],\n  [14, 6, 20, 14]\n]\nmoyenne_series(series)\n# retourne la chaîne:\nS1: 10.4\nS2: 8.3\nS3: 13.5\n```\n",
        "tests": "from unittest.mock import patch\nfrom unittest import TestCase\nfrom inspect import getmembers, signature, getsource\n\nimport sys\nimport imp\nfrom contextlib import contextmanager\nfrom io import StringIO\nimport pytest\n\n@contextmanager\ndef captured_output():\n    new_out = StringIO()\n    old_out = sys.stdout\n    try:\n        sys.stdout = new_out\n        yield sys.stdout\n    finally:\n        sys.stdout = old_out\n\ndef load_module():\n    if 'moduletotest' in sys.modules:\n        imp.reload(sys.modules['moduletotest'])\n    else:\n        import moduletotest\n\ndef check_value(var, value):\n    members = getmembers(sys.modules['moduletotest'])\n    elem = [item for item in members if item[0] == var]\n    assert len(elem) == 1, \"'%s' n'existe pas\" % (var)\n    assert elem[0][1] == value, \"'%s' n'a pas la valeur '%s'\" % (var, value)\n\n\ndef get_function(var):\n    members = getmembers(sys.modules['moduletotest'])\n    elem = [item for item in members if item[0] == var]\n    assert len(elem) == 1, \"'%s' n'est pas définie\" % (var)\n    function = elem[0][1]\n    assert callable(function) == True, \"le symbole 'puissance' n'est pas une fonction\"\n    return function\n\ndef get_userdefined_variables():\n    return [item for item in dir(sys.modules['moduletotest']) if not item.startswith(\"__\")]\n\ndef get_cleaned_output(out, lines, check = False):\n    output = out.getvalue().scompressionp()\n    l = output.split('\\n')\n    if check == True:\n        assert len(l[-lines:]) == lines, \"Pas assez de lignes affichées !\"\n    return l[-lines:]\n\ndef no_input (*args):\n    raise Exception(\"Aucune entrée utilisateur (input) ne doit être utilisée !\")\n\ndef no_print (*args):\n    raise Exception(\"Aucun affichage (print) ne doit être utilisé !\")\n\nclass Test(TestCase):\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_is_function(self, input, print):\n        with captured_output() as out:\n            load_module()\n        moyenne_series = get_function(\"moyenne_series\")\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_function_params(self, input, print):\n        with captured_output() as out:\n            load_module()\n        sig = signature(get_function(\"moyenne_series\"))\n        assert len(sig.parameters) == 1, \"Votre fonction moyenne_series ne prend pas exactement un paramètre\"\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_1(self, input, print):\n        with captured_output() as out:\n            load_module()\n        moyenne_series = get_function(\"moyenne_series\")\n        assert moyenne_series([[10, 7, 16, 8, 11], [2, 20, 3], [14, 6, 20, 14]]) == 'S1: 10.4\\nS2: 8.3\\nS3: 13.5', \\\n                \"moyenne_series([[10, 7, 16, 8, 11], [2, 20, 3], [14, 6, 20, 14]]) devrait retourner: 'S1: 10.4\\nS2: 8.3\\nS3: 13.5'\"\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_2(self, input, print):\n        with captured_output() as out:\n            load_module()\n        moyenne_series = get_function(\"moyenne_series\")\n        assert moyenne_series([[11, 12, 13, 14, 0], [2, 20, 13, 12, -1]]) == 'S1: 10.0\\nS2: 9.2', \\\n                \"moyenne_series([[11, 12, 13, 14, 0], [2, 20, 13, 12, -1]]) devrait retourner: 'S1: 10.0\\nS2: 9.2'\"\n",
        "solution": "def moyenne_series (series):\n    out = ''\n    for i, serie in enumerate(series):\n        somme = 0\n        for j in serie:\n            somme += j\n        out += 'S{0}: {1:0.1f}'.format(i + 1, somme / len(serie))\n        if i + 1 < len(series):\n            out += '\\n'\n    return out\n",
        "template_regions": [
          ""
        ],
        "template_regions_rw": [
          0
        ],
        "difficulty": 0,
        "score": 0,
        "creation_date": "2020-02-28T12:32:53.160Z"
      },
      {
        "sequence_id": 2,
        "title": "Triangle de Pascal",
        "lang": "python",
        "instructions": "Écrire une fonction `pascal` qui prend en paramètre un entier `n` et retourne sous forme de tableau à deux dimensions les `n` premières lignes du triangle de Pascal de la façon suivante:\n```\nExemple avec n = 5\npascal(5)\n# retourne\n[\n  [1],\n  [1, 1],\n  [1, 2, 1],\n  [1, 3, 3, 1],\n  [1, 4, 6, 4, 1]\n]\n```\n",
        "tests": "from unittest.mock import patch\nfrom unittest import TestCase\nfrom inspect import getmembers, signature, getsource\n\nimport sys\nimport imp\nfrom contextlib import contextmanager\nfrom io import StringIO\nimport pytest\n\n@contextmanager\ndef captured_output():\n    new_out = StringIO()\n    old_out = sys.stdout\n    try:\n        sys.stdout = new_out\n        yield sys.stdout\n    finally:\n        sys.stdout = old_out\n\ndef load_module():\n    if 'moduletotest' in sys.modules:\n        imp.reload(sys.modules['moduletotest'])\n    else:\n        import moduletotest\n\ndef check_value(var, value):\n    members = getmembers(sys.modules['moduletotest'])\n    elem = [item for item in members if item[0] == var]\n    assert len(elem) == 1, \"'%s' n'existe pas\" % (var)\n    assert elem[0][1] == value, \"'%s' n'a pas la valeur '%s'\" % (var, value)\n\n\ndef get_function(var):\n    members = getmembers(sys.modules['moduletotest'])\n    elem = [item for item in members if item[0] == var]\n    assert len(elem) == 1, \"'%s' n'est pas définie\" % (var)\n    function = elem[0][1]\n    assert callable(function) == True, \"le symbole 'puissance' n'est pas une fonction\"\n    return function\n\ndef get_userdefined_variables():\n    return [item for item in dir(sys.modules['moduletotest']) if not item.startswith(\"__\")]\n\ndef get_cleaned_output(out, lines, check = False):\n    output = out.getvalue().scompressionp()\n    l = output.split('\\n')\n    if check == True:\n        assert len(l[-lines:]) == lines, \"Pas assez de lignes affichées !\"\n    return l[-lines:]\n\ndef no_input (*args):\n    raise Exception(\"Aucune entrée utilisateur (input) ne doit être utilisée !\")\n\ndef no_print (*args):\n    raise Exception(\"Aucun affichage (print) ne doit être utilisé !\")\n\nclass Test(TestCase):\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_is_function(self, input, print):\n        with captured_output() as out:\n            load_module()\n        pascal = get_function(\"pascal\")\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_function_params(self, input, print):\n        with captured_output() as out:\n            load_module()\n        sig = signature(get_function(\"pascal\"))\n        assert len(sig.parameters) == 1, \"Votre fonction pascal ne prend pas exactement un paramètre\"\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_1(self, input, print):\n        with captured_output() as out:\n            load_module()\n        pascal = get_function(\"pascal\")\n        assert pascal(0) == [[1]], \\\n                \"pascal(0) devrait retourner: [[1]]\"\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_2(self, input, print):\n        with captured_output() as out:\n            load_module()\n        pascal = get_function(\"pascal\")\n        assert pascal(5) == [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]], \\\n                \"pascal(5) devrait retourner: [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\"\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_3(self, input, print):\n        with captured_output() as out:\n            load_module()\n        pascal = get_function(\"pascal\")\n        assert pascal(15) == [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1], [1, 5, 10, 10, 5, 1], [1, 6, 15, 20, 15, 6, 1], [1, 7, 21, 35, 35, 21, 7, 1], [1, 8, 28, 56, 70, 56, 28, 8, 1], [1, 9, 36, 84, 126, 126, 84, 36, 9, 1], [1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1], [1, 11, 55, 165, 330, 462, 462, 330, 165 , 55, 11, 1], [1, 12, 66, 220, 495, 792, 924, 792, 495, 220, 66, 12, 1], [1, 13, 78, 286, 715, 1287 , 1716, 1716, 1287, 715, 286, 78, 13, 1], [1, 14, 91, 364, 1001, 2002, 3003, 3432, 3003, 2002, 1001, 364, 91, 14, 1]], \\\n                \"pascal(15) devrait retourner: [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1], [1, 5, 10, 10, 5, 1], [1, 6, 15, 20, 15, 6, 1], [1, 7, 21, 35, 35, 21, 7, 1], [1, 8, 28, 56, 70, 56, 28, 8, 1], [1, 9, 36, 84, 126, 126, 84, 36, 9, 1], [1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1], [1, 11, 55, 165, 330, 462, 462, 330, 165, 55, 11, 1], [1, 12, 66, 220, 495, 792, 924, 792, 495, 220, 66, 12, 1], [1, 13, 78, 286, 715, 1287, 1716, 1716, 1287, 715, 286, 78, 13, 1], [1, 14, 91, 364, 1001, 2002, 3003, 3432, 3003, 2002, 1001, 364, 91, 14, 1]]\"\n",
        "solution": "def pascal (n):\n    out = [[1]]\n    if n == 0:\n        return out\n    prev = [1]\n    for i in range(0, n - 1):\n        curr = [1]\n        for j in range(0, len(prev)):\n            somme = prev[j]\n            if j < len(prev) - 1:\n                somme += prev[j + 1]\n            curr.append(somme)\n        prev = curr\n        out.append(prev)\n    return out\n# print(pascal(15))\n",
        "template_regions": [
          ""
        ],
        "template_regions_rw": [
          0
        ],
        "difficulty": 0,
        "score": 0,
        "creation_date": "2020-02-28T12:32:53.160Z"
      },
      {
        "sequence_id": 3,
        "title": "Table de multiplication",
        "lang": "python",
        "instructions": "Écrire une fonction `table_multiplication` qui prend en paramètre un entier `n`, génère et retourne sous forme de chaîne de caractères sa table de multiplications de la manière suivante:\n\n```\nExemple avec n = 10\n    |  1   2   3   4   5   6   7   8   9  10\n--------------------------------------------\n  1 |  1   2   3   4   5   6   7   8   9  10\n  2 |  2   4   6   8  10  12  14  16  18  20\n  3 |  3   6   9  12  15  18  21  24  27  30\n  4 |  4   8  12  16  20  24  28  32  36  40\n  5 |  5  10  15  20  25  30  35  40  45  50\n  6 |  6  12  18  24  30  36  42  48  54  60\n  7 |  7  14  21  28  35  42  49  56  63  70\n  8 |  8  16  24  32  40  48  56  64  72  80\n  9 |  9  18  27  36  45  54  63  72  81  90\n 10 | 10  20  30  40  50  60  70  80  90 100\n\nExemple avec n = 15\n   |   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15\n----------------------------------------------------------------\n  1|   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15\n  2|   2   4   6   8  10  12  14  16  18  20  22  24  26  28  30\n  3|   3   6   9  12  15  18  21  24  27  30  33  36  39  42  45\n  4|   4   8  12  16  20  24  28  32  36  40  44  48  52  56  60\n  5|   5  10  15  20  25  30  35  40  45  50  55  60  65  70  75\n  6|   6  12  18  24  30  36  42  48  54  60  66  72  78  84  90\n  7|   7  14  21  28  35  42  49  56  63  70  77  84  91  98 105\n  8|   8  16  24  32  40  48  56  64  72  80  88  96 104 112 120\n  9|   9  18  27  36  45  54  63  72  81  90  99 108 117 126 135\n 10|  10  20  30  40  50  60  70  80  90 100 110 120 130 140 150\n 11|  11  22  33  44  55  66  77  88  99 110 121 132 143 154 165\n 12|  12  24  36  48  60  72  84  96 108 120 132 144 156 168 180\n 13|  13  26  39  52  65  78  91 104 117 130 143 156 169 182 195\n 14|  14  28  42  56  70  84  98 112 126 140 154 168 182 196 210\n 15|  15  30  45  60  75  90 105 120 135 150 165 180 195 210 225\n```\n",
        "tests": "from unittest.mock import patch\nfrom unittest import TestCase\nfrom inspect import getmembers, signature, getsource\n\nimport sys\nimport imp\nfrom contextlib import contextmanager\nfrom io import StringIO\nimport pytest\n\n@contextmanager\ndef captured_output():\n    new_out = StringIO()\n    old_out = sys.stdout\n    try:\n        sys.stdout = new_out\n        yield sys.stdout\n    finally:\n        sys.stdout = old_out\n\ndef load_module():\n    if 'moduletotest' in sys.modules:\n        imp.reload(sys.modules['moduletotest'])\n    else:\n        import moduletotest\n\ndef check_value(var, value):\n    members = getmembers(sys.modules['moduletotest'])\n    elem = [item for item in members if item[0] == var]\n    assert len(elem) == 1, \"'%s' n'existe pas\" % (var)\n    assert elem[0][1] == value, \"'%s' n'a pas la valeur '%s'\" % (var, value)\n\n\ndef get_function(var):\n    members = getmembers(sys.modules['moduletotest'])\n    elem = [item for item in members if item[0] == var]\n    assert len(elem) == 1, \"'%s' n'est pas définie\" % (var)\n    function = elem[0][1]\n    assert callable(function) == True, \"le symbole 'puissance' n'est pas une fonction\"\n    return function\n\ndef get_userdefined_variables():\n    return [item for item in dir(sys.modules['moduletotest']) if not item.startswith(\"__\")]\n\ndef get_cleaned_output(out, lines, check = False):\n    output = out.getvalue().scompressionp()\n    l = output.split('\\n')\n    if check == True:\n        assert len(l[-lines:]) == lines, \"Pas assez de lignes affichées !\"\n    return l[-lines:]\n\ndef no_input (*args):\n    raise Exception(\"Aucune entrée utilisateur (input) ne doit être utilisée !\")\n\ndef no_print (*args):\n    raise Exception(\"Aucun affichage (print) ne doit être utilisé !\")\n\ndef power_of_ten (n):\n    count = 1\n    divided = n\n    while divided >= 10:\n        count += 1\n        divided /= 10\n    return count\n\ndef formatnbr (j, power):\n    jpow = power_of_ten(j)\n    return ' ' * (power - jpow) + str(j)\n\ndef formatrow (n, step, power):\n    curr = ' |'\n    for j in range(step, n + 1, step):\n        curr += ' ' + formatnbr(j, power)\n    return curr\n\ndef table_multiplication_test (n):\n    out = ' '\n    power = power_of_ten(n)\n    powermax = power_of_ten(n * n)\n    out += ' ' * power\n    out += formatrow(n, 1, powermax) + '\\n'\n    out += '-' * (len(out) - 1) + '\\n'\n    for i in range(1, n + 1):\n        out += ' ' + formatnbr(i, power) + formatrow(n * i, i, powermax) + '\\n'\n    return out\n\nclass Test(TestCase):\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_is_function(self, input, print):\n        with captured_output() as out:\n            load_module()\n        table_multiplication = get_function(\"table_multiplication\")\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_function_params(self, input, print):\n        with captured_output() as out:\n            load_module()\n        sig = signature(get_function(\"table_multiplication\"))\n        assert len(sig.parameters) == 1, \"Votre fonction table_multiplication ne prend pas exactement un paramètre\"\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_1(self, input, print):\n        with captured_output() as out:\n            load_module()\n        table_multiplication = get_function(\"table_multiplication\")\n        assert table_multiplication(9) == table_multiplication_test(9), \\\n                \"\"\"table_multiplication(9) devrait retourner: \n   |  1  2  3  4  5  6  7  8  9\n-------------------------------\n 1 |  1  2  3  4  5  6  7  8  9\n 2 |  2  4  6  8 10 12 14 16 18\n 3 |  3  6  9 12 15 18 21 24 27\n 4 |  4  8 12 16 20 24 28 32 36\n 5 |  5 10 15 20 25 30 35 40 45\n 6 |  6 12 18 24 30 36 42 48 54\n 7 |  7 14 21 28 35 42 49 56 63\n 8 |  8 16 24 32 40 48 56 64 72\n 9 |  9 18 27 36 45 54 63 72 81\n\"\"\"\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_2(self, input, print):\n        with captured_output() as out:\n            load_module()\n        table_multiplication = get_function(\"table_multiplication\")\n        assert table_multiplication(10) == table_multiplication_test(10), \\\n                \"\"\"table_multiplication(9) devrait retourner: \n    |  1   2   3   4   5   6   7   8   9  10\n--------------------------------------------\n  1 |  1   2   3   4   5   6   7   8   9  10\n  2 |  2   4   6   8  10  12  14  16  18  20\n  3 |  3   6   9  12  15  18  21  24  27  30\n  4 |  4   8  12  16  20  24  28  32  36  40\n  5 |  5  10  15  20  25  30  35  40  45  50\n  6 |  6  12  18  24  30  36  42  48  54  60\n  7 |  7  14  21  28  35  42  49  56  63  70\n  8 |  8  16  24  32  40  48  56  64  72  80\n  9 |  9  18  27  36  45  54  63  72  81  90\n 10 | 10  20  30  40  50  60  70  80  90 100\n\"\"\"\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_2(self, input, print):\n        with captured_output() as out:\n            load_module()\n        table_multiplication = get_function(\"table_multiplication\")\n        assert table_multiplication(15) == table_multiplication_test(15), \\\n                \"\"\"Il y a une incohérence dans votre chaîne pour table_multiplication(15), trouvez le problème.\"\"\"\n\n    @pytest.mark.timeout(1)\n    @patch('builtins.input', side_effect=no_input)\n    @patch('builtins.print', side_effect=no_print)\n    def test_2(self, input, print):\n        with captured_output() as out:\n            load_module()\n        table_multiplication = get_function(\"table_multiplication\")\n        assert table_multiplication(38) == table_multiplication_test(38), \\\n                \"\"\"Il y a une incohérence dans votre chaîne pour table_multiplication(38), trouvez le problème.\"\"\"\n",
        "solution": "def power_of_ten (n):\n    count = 1\n    divided = n\n    while divided >= 10:\n        count += 1\n        divided /= 10\n    return count\n\ndef formatnbr (j, power):\n    jpow = power_of_ten(j)\n    return ' ' * (power - jpow) + str(j)\n\ndef formatrow (n, step, power):\n    curr = ' |'\n    for j in range(step, n + 1, step):\n        curr += ' ' + formatnbr(j, power)\n    return curr\n\ndef table_multiplication (n):\n    out = ' '\n    power = power_of_ten(n)\n    powermax = power_of_ten(n * n)\n    out += ' ' * power\n    out += formatrow(n, 1, powermax) + '\\n'\n    out += '-' * (len(out) - 1) + '\\n'\n    for i in range(1, n + 1):\n        out += ' ' + formatnbr(i, power) + formatrow(n * i, i, powermax) + '\\n'\n    return out\n",
        "template_regions": [
          ""
        ],
        "template_regions_rw": [
          0
        ],
        "difficulty": 0,
        "score": 0,
        "creation_date": "2020-02-28T12:32:53.161Z"
      },
      {
        "sequence_id": 4,
        "title": "Carré magique",
        "lang": "python",
        "instructions": "Écrire une fonction `carre_magique` qui prend en paramètre un tableau 2D de n * n entiers.\n\na) Dans un premier temps, le programme doit vérifier si le carré est magique (la somme des valeurs sur chaque\nligne, sur chaque colonne et sur les deux diagonales est la même), et retourner [True](https://docs.python.org/fr/3/library/stdtypes.html#boolean-values) si le carré est magique, False sinon.\nmagique\"\n\nExemple de carré magique:\n```\n14 |  5 | 17\n-----------\n15 | 12 |  9\n-----------\n 7 | 19 | 10\nSa représentation en tableau 2D est:\n[\n [14, 5, 17],\n [15, 12, 9],\n [7, 19, 10]\n]\n```\n\nb) Dans un second temps, une nouvelle fonction `carre_magique_parfait` doit vérifier que le carré est magique parfait (carré qui contient toutes les valeurs de n à n^2)\n```\n 8 | 1 | 6\n-----------\n 3 | 5 | 7\n-----------\n 4 | 9 | 2\n\n```\n",
        "tests": "",
        "solution": "",
        "template_regions": [
          ""
        ],
        "template_regions_rw": [
          0
        ],
        "difficulty": 0,
        "score": 0,
        "creation_date": "2020-02-28T12:32:53.161Z"
      },
      {
        "sequence_id": 5,
        "title": "Solveur du nombre secret",
        "lang": "python",
        "instructions": "Écrivez un algorithme dont le but est de deviner le nombre auquel pense\nl'utilisateur, et qui prend en entrée soit un plus (+), soit un moins (-), soit\nun égal (=).\n\nRègles:\n* Le nombre est compris entre 0 et 1000, inclus\n* Le programme doit s'arrêter après 10 tentatives (= échec)\n* Si l'utilisateur entre le caractère \"=\", le programme a gagné\n\nVotre programme doit être capable de deviner **systématiquement** le nombre de\nl'utilisateur en maximum 10 essais.\n",
        "tests": "",
        "solution": "",
        "template_regions": [
          ""
        ],
        "template_regions_rw": [
          0
        ],
        "difficulty": 0,
        "score": 0,
        "creation_date": "2020-02-28T12:32:53.162Z"
      }
    ]
  }
]